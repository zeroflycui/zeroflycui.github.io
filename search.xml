<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈与队列</title>
      <link href="/6534ce06.html"/>
      <url>/6534ce06.html</url>
      
        <content type="html"><![CDATA[<hr><p><img src="/6534ce06/image-20200428190107477.png" alt="image-20200428190107477"></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><blockquote><p>栈：限定<strong>仅</strong>在表尾进行插入和删除操作的<strong>线性表</strong>。</p></blockquote><p>栈又称为<strong>后进先出</strong>（Last In First Out）线性表，简称LIFO结构。</p><img src="/6534ce06/image-20200425084743968.png" alt="image-20200425084743968" style="zoom:50%;"><p>栈对线性表的插入和删除的位置进行了限制，但是并没有对何时插入与删除进行限制，在<strong>不是所有元素都进栈，并保证栈顶元素出栈的情况下</strong>，先进入的可以不必最后出。</p><h2 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>对于顺序存储结构，可以通过数组来实现。一般将下标为0的一端作为栈底，这样当存入和删除元素时，数组变化最小。定义top变量指代栈顶元素在数组中的位置，但是top变量必须小于数组的长度。<strong>当栈存在一个元素时，top记为0，因此把空栈的top记为-1</strong>.</p><p>假设有5个元素下栈的几种可能情况。</p><img src="/6534ce06/image-20200425095242395.png" alt="image-20200425095242395" style="zoom:50%;"><p>push操作代码：</p><img src="/6534ce06/image-20200425095700751.png" alt="image-20200425095700751" style="zoom:50%;"><p>pop操作代码：</p><img src="/6534ce06/image-20200425095740831.png" alt="image-20200425095740831" style="zoom:50%;"><h4 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h4><p>为了最大程度上利用数组的空间，可以通过将两个<strong>同类型</strong>的栈组合起来，一起共享数组空间。将两个栈底分别作为数组的起始端和末端。如图：</p><img src="/6534ce06/image-20200425101135540.png" alt="image-20200425101135540" style="zoom:50%;"><p>只要top1和top2两个栈顶指针不相遇，两个栈就可以一直使用。</p><blockquote><p>当top1等于-1时，栈1为空；当top2等于n时，栈2为空。</p><p>当栈2为空，top1等于n-1时，栈1满栈；当top2等于0时，栈2满栈。</p></blockquote><p>当两个指针之间相差1时，即 top1 + 1 == top2 时栈是满栈。</p><p>两栈共享空间的push操作代码：</p><img src="/6534ce06/image-20200425104129706.png" alt="image-20200425104129706" style="zoom:50%;"><p>注意，红色部分，++i 与 i++ 的区别。</p><p>pop操作代码：</p><img src="/6534ce06/image-20200425104320630.png" alt="image-20200425104320630" style="zoom:50%;"><p>使用这种数据结构，通常是两个栈的空间需求有相反关系时，即一个栈空间增加而另一个栈空间缩小。</p><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>栈的链式存储结构，可以简称为链栈。</p><p>由于链表含有头指针的单链表头，因此可以通过单链表头作为栈顶。效果图如下：</p><img src="/6534ce06/image-20200425105324677.png" alt="image-20200425105324677" style="zoom:50%;"><p>对于空栈来说，由于空链表定义的头指针指向空，则链栈的空其实就是 top=NULL。</p><p>push操作代码：</p><img src="/6534ce06/image-20200425110352448.png" alt="image-20200425110352448" style="zoom:50%;"><img src="/6534ce06/image-20200425110545084.png" alt="image-20200425110545084" style="zoom:50%;"><p>pop操作：</p><img src="/6534ce06/image-20200425110723458.png" alt="image-20200425110723458" style="zoom:50%;"><img src="/6534ce06/image-20200425110750706.png" alt="image-20200425110750706" style="zoom:50%;"><p>通过链栈和顺序栈的比较可知：<strong>在栈的使用过程中，若使用的元素变化不可预测，时大时小，则最好使用链栈，若知道在可控的范围内，则使用顺序栈更好</strong>。</p><h2 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h2><p>栈的引用，简化了程序设计的问题，划分了不同关注层次，使思考范围缩小，更聚焦当前要解决的问题。数组之类的，还需要分散精力去考虑数组下标增减等细节问题。</p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>定义：<strong>直接调用自己或通过一些列的调用语句间接地调用自己的函数，称作递归函数。</strong></p><p><strong>注意：</strong>递归的最大陷阱就是要防止进入<strong>无限递归</strong>因此在<strong>每个递归定义必须至少有一个条件，满足时递归不再进行。</strong></p><p>运用递归能使程序的<strong>结构更清晰、更简洁、更容易理解，从而减少读懂代码的时间</strong>。但是大量的递归调用会建立函数的副本，会<strong>耗费大量时间和内存</strong>。迭代则不需要反复调用函数和占用额外的内存。</p><p>栈和递归的关系：</p><p>在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址<strong>都被压入栈</strong>中。在退回阶段，位于栈顶的局部变量、参数值和返回地址<strong>被弹出</strong>，用于返回调用层次中执行代码的其余部分，即恢复调用的状态。</p><h3 id="四则运算表达式求值"><a href="#四则运算表达式求值" class="headerlink" title="四则运算表达式求值"></a>四则运算表达式求值</h3><p>后缀表达式规则：</p><p>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。<br>$$<br>9+(3-1)×3+10÷2<br>$$<br>示例:</p><p><img src="/6534ce06/image-20200425180452247.png" alt="image-20200425180452247"></p><p>在平常的四则运算中的表达式叫做中缀表达式。中缀表达式转换为后缀表达式的规则：</p><p><strong>从左到右遍历表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</strong></p><p>想让计算机处理常用的中缀表达式，最重要的是以下两步：</p><ul><li>将中缀表达式转化为后缀表达式（栈用来<strong>进出运算的符号</strong>）</li><li>将后缀表达式进行运算得出结果（栈用来<strong>进出运算的数字</strong>）</li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列（queue）是<strong>只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong></p><p>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为对头。</p><img src="/6534ce06/image-20200426080824944.png" alt="image-20200426080824944" style="zoom:50%;"><h2 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h2><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>队列的顺序存储结构需要建立一个大于n的数组，但是由于队列的特殊性（先进先出）入队操作，只需在数组后加一个元素，不需要移动任何元素，此时复杂度为O(1)。但是，在出队操作时，需要删除数组第一个元素，则需要把<strong>所有</strong>元素都向前移动，此时的时间复杂度为O(n)。</p><img src="/6534ce06/image-20200426083633132.png" alt="image-20200426083633132" style="zoom:50%;"><p>为了避免出队列时，增加时间复杂度，引入两个指针，front指针指向队头元素，rear指针指向队尾元素的<strong>下一个位置</strong>，当front等于rear时，此队列是空队列。</p><img src="/6534ce06/image-20200426084014937.png" alt="image-20200426084014937" style="zoom:50%;"><p>假溢出：在入队时，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，而且<strong>队列的前端还有空闲</strong>，把这种现象称为假溢出。</p><img src="/6534ce06/image-20200426084643305.png" alt="image-20200426084643305" style="zoom:50%;"><p>为了解决假溢出的问题，引入了循环队列：把队列的头尾相接的顺序存储结构称为循环队列。</p><img src="/6534ce06/image-20200426090055084.png" alt="image-20200426090055084" style="zoom:50%;"><p>但此时的问题是：当front指针等于rear指针时，此时队列为空。但是此时，front指针等于rear指针，队列为满。</p><p>那么如何判断当front指针等于rear时，队列是空还是满呢？</p><ul><li>设置一个标志变量flag，当front==rear，且flag = 0时队列为空，当flag=1时队列为满。</li><li>办法二，当队列为空时，条件就是front ==rear，当队列满时，修改其条件，<strong>保留一个元素空间</strong>。</li></ul><img src="/6534ce06/image-20200426092144219.png" alt="image-20200426092144219" style="zoom:50%;"><p>上图即为方法二的满队情况。</p><p>在满队的情况下，rear有可能比front大也可能小。需要通过以下方法来判断队列满。</p><p>设队列的最大尺寸为QueueSize,那么队列满的条件是<strong>(rear+1)%QueueSize == front</strong>.</p><p><strong>通用的队列长度计算公式：</strong>（rear-front + QueueSize）%QueueSize</p><p>循环队列的顺序存储结构代码如下：</p><img src="/6534ce06/image-20200426093308450.png" alt="image-20200426093308450" style="zoom:50%;"><p>循环队列的初始化代码如下：</p><img src="/6534ce06/image-20200426093357676.png" alt="image-20200426093357676" style="zoom:50%;"><p>循环队列求长度代码：</p><img src="/6534ce06/image-20200426093550305.png" alt="image-20200426093550305" style="zoom:50%;"><p>循环队列的入队操作：</p><img src="/6534ce06/image-20200426093644631.png" alt="image-20200426093644631" style="zoom:50%;"><p>循环队列的出队操作：</p><img src="/6534ce06/image-20200426093915183.png" alt="image-20200426093915183" style="zoom:50%;"><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><p> 队列的链式存储结构，其实就是线性表的单链表，只是只能尾进头出，简称为链队列。将头指针指向链队列的头结点，队尾指针指向终端结点。</p><img src="/6534ce06/image-20200426100400135.png" alt="image-20200426100400135" style="zoom:50%;"><p>当队列为空时，头指针和尾指针都指向头结点。</p><img src="/6534ce06/image-20200426100532695.png" alt="image-20200426100532695" style="zoom:50%;"><p>入队操作：</p><p><img src="/6534ce06/image-20200426100623318.png" alt="image-20200426100623318"></p><p><img src="/6534ce06/image-20200426100751336.png" alt="image-20200426100751336"></p><p>出队操作：</p><p><img src="/6534ce06/image-20200426100826898.png" alt="image-20200426100826898"></p><img src="/6534ce06/image-20200426101449339.png" alt="image-20200426101449339" style="zoom:50%;"><p>在可以确定队列长度最大值的情况下，建议用循环队列，若无法预估计队列的长度时，则用链队列。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表笔记之于大话数据结构</title>
      <link href="/b6f9ab9c.html"/>
      <url>/b6f9ab9c.html</url>
      
        <content type="html"><![CDATA[<hr><p>本文主要是通过阅读大话数据结构第三章，总结一些自己对线性表得所得与所想，希望能对您有所帮助，也为方便自己日后查阅。若有错误之处，请大佬指出:happy:</p><a id="more"></a><p><img src="/b6f9ab9c/image-20200410172957516.png" alt></p><h1 id="线性表得定义"><a href="#线性表得定义" class="headerlink" title="线性表得定义"></a>线性表得定义</h1><p><code>定义：零个或多个数据元素的有限序列。</code></p><p>线性表有以下特性：</p><blockquote><p>线性表是个序列。元素之间是<strong><em>有顺序</em></strong>的，除第一个和最后一个，每个元素都<strong>有且只有</strong>一个前驱和后继。</p><blockquote><p>线性表是<strong><em>有限的</em></strong>。</p><p>数据元素的类型是一样的。</p></blockquote></blockquote><h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p>线性链表的抽象数据类型，也就是时说线性表应该有什么样的操作呢。</p><p>线性表的抽象数据类型定义如下：</p><img src="/b6f9ab9c/3.1.jpg" style="zoom:33%;"><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p>顺序存储结构定义：<code>用一段地址连续的存储单元依次存储线性表的数据元素。</code></p><p>线性表的存储示意图如下：</p><img src="/b6f9ab9c/3.2.jpg" style="zoom:33%;"><h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><p>可以通过<strong>一维数组来实现顺序存储结构</strong>。</p><p>线性表的顺序存储的结构代码：</p><p><img src="/b6f9ab9c/3.3.jpg" alt></p><h3 id="数据长度与线性表长度区别"><a href="#数据长度与线性表长度区别" class="headerlink" title="数据长度与线性表长度区别"></a>数据长度与线性表长度区别</h3><p>区别如下：</p><p><img src="/b6f9ab9c/image-20200410094544007.png" alt="image-20200410094544007"></p><h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3><p>由于存储器中的每个存储单元都有自己的编号，即地址。假设每个数据元素都占用一个固定的存储单元c，那么可以得到任意存储位置的地址：<br>$$<br>LOC(a_i)=LOC(a_1)+(i-1)*c<br>$$<br>对顺序存储结构的线性表来说，存入或者取出数据，的时间复杂度都为O(1)。通常把具有这一特点的存储结构称为随机存取结构。</p><h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>要是实现获得数据GetElem操作，只要 i 的数值在数组下标范围内，就是把数组第 <code>i-1</code>下标返回即可。代码如下：</p><p><img src="/b6f9ab9c/3.5.jpg" alt></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>要实现<code>ListInsert(*L,i,e)</code>，即在线性表L中的第i个位置插入新元素e，该如何操作？</p><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表长度大于数组长度，则抛出异常或动态增加容量；</li><li>从<strong>最后一个元素开始向前遍历</strong>到第 <code>i</code> 个位置，分别将它们都向后移动一个位置；</li><li>将要插入的元素填入位置<code>i</code>处；</li><li>表长加1；</li></ul><p>代码实现如下：</p><img src="/b6f9ab9c/3.6.jpg" style="zoom:50%;"><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常；</li><li>取出删除元素；</li><li>从<strong>删除元素位置</strong>，开始遍历到最后一个元素位置，分别将它们都向前移动一个个位置；</li><li>表长减1；</li></ul><p>实现代码如下：</p><p><img src="/b6f9ab9c/3.7.jpg" alt></p><p>插入和删除的时间复杂度都为<code>O(n)</code></p><h4 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h4><p>优缺点总结如下：</p><p><img src="/b6f9ab9c/image-20200410104532727.png" alt="image-20200410104532727"></p><h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><p>线性链表的特点：</p><ul><li>用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这些元素可以在未被占用内存的任意位置。</li></ul><p>链式存储结构的组成部分：</p><ul><li>数据域：用来存储数值信息；</li><li>指针域：用来指向后继元素存储地址的指针。</li></ul><p>把一个元素的指针域和数据域组成的存储映像，称为<strong>节点</strong>。</p><img src="/b6f9ab9c/image-20200410105654619.png" alt="image-20200410105654619" style="zoom:50%;"><p><strong>把链表中第一个节点的存储位置叫做头指针</strong>，整个链表都是从头指针开始进行的。</p><p>最后一个节点的指针为空（通常用<code>NULL</code>或<code>&quot;^&quot;</code>表示）。</p><img src="/b6f9ab9c/image-20200410110627268.png" alt="image-20200410110627268" style="zoom:50%;"><p>通常在第一个节点前添加一个头节点。头节点的数据域可以为空，也可以存储线性表的长度等附加信息。</p><p>头节点和头指针的区别：</p><img src="/b6f9ab9c/image-20200410112358275.png" alt="image-20200410112358275" style="zoom:50%;"><p>通过下图可更加直观的明白头指针和头结点大的区别：</p><img src="/b6f9ab9c/3.8.jpg" style="zoom:50%;"><p>假设<code>p</code>是指向线性表的第<code>i</code>个元素的指针，该结点的数据域为<code>p-&gt;data</code>值是一个数据元素，指针域为<code>p-&gt;next</code>是一个指针。</p><img src="/b6f9ab9c/image-20200410113228723.png" alt="image-20200410113228723" style="zoom:50%;"><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><p>获得链表第<code>i</code>个数据的算法思路：</p><ul><li>声明一个结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从<code>1</code>开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让<code>p</code>的指针向后移动，不断指向下一个结点，<code>j</code>累加1；</li><li>若到链表末尾<code>p</code>为空，则说明第<code>i</code>个元素不存在；</li><li>否则查找成功，返回结点<code>p</code>的数据；</li></ul><p>实现代码为：</p><img src="/b6f9ab9c/3.9.jpg" style="zoom:50%;"><p>简单说就是从头开始遍历，直到第<code>i</code>个元素为止。此时的时间复杂度，最差为<code>O(n)</code></p><h4 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h4><img src="/b6f9ab9c/image-20200410115837689.png" alt="image-20200410115837689" style="zoom:50%;"><p>要把<code>s</code>结点插入，则只需，<code>s-&gt;next=p-&gt;next</code>和<code>p-&gt;next=s</code>即可。切记这<strong>两句命令不能顺序颠倒</strong>。把p的后继结点改为s的后继结点，再把结点s改成p的后继结点。</p><p>在表头和表尾的插入操作：</p><img src="/b6f9ab9c/image-20200410120406379.png" alt="image-20200410120406379" style="zoom:50%;"><p>单链表第i个数据插入结点的算法思路：</p><ul><li>声明一个结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从1开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让<code>p</code>的指针向后移动，不断指向下一结点，<code>j</code>累加1；</li><li>若到链表末尾<code>p</code>为空，则说明第<code>i</code>个元素不存在；</li><li>否则查找成功，在系统中生成一个空结点s；</li><li>将数据元素<code>e</code>赋值给<code>s-&gt;data</code>；</li><li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next; p-&gt;next=s;</code>;</li><li>返回成功；</li></ul><p>代码如下：</p><img src="/b6f9ab9c/image-20200410130928070.png" alt="image-20200410130928070" style="zoom:50%;"><h4 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h4><img src="/b6f9ab9c/image-20200410131049102.png" alt="image-20200410131049102" style="zoom:50%;"><p>只需要做<code>p-&gt;next=p-&gt;next-&gt;next</code>,即可。令<code>q=p-&gt;next</code>。</p><p>单链表删除的算法步骤：</p><ul><li>声明一结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从<code>1</code>开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，<code>j</code>累加1；</li><li>若链表末尾p为空，则说明第 i 个元素不存在；</li><li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li><li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>;</li><li>将<code>q</code>结点中的数据赋值给<code>e</code>，作为返回；</li><li>释放<code>q</code>结点；</li><li>返回成功；</li></ul><p>实现代码如下：</p><img src="/b6f9ab9c/image-20200410131903592.png" alt="image-20200410131903592" style="zoom:50%;"><h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><p>创建单链表的过程是一个动态生成链表的过程，即从空表的初始状态，依次建立各元素结点，并逐个插入链表。</p><p>头插法：</p><p>单链表整表创建的算法思路：</p><ul><li>声明一个结点<code>p</code>和计数器变量<code>i</code>;</li><li>初始化一个空链表L；</li><li>让<code>L</code>的头结点的指针指向NULL,即建立一个带头结点的单链表；</li><li>循环：<ul><li>生成一个新节点赋值给<code>p</code>；</li><li>随机生成一个数字赋值给<code>p</code>的数据域<code>p-&gt;data</code>；</li><li>将<code>p</code>插入到头结点与之前新一结点之间；</li></ul></li></ul><p>代码实现如下：</p><img src="/b6f9ab9c/3.10.jpg" style="zoom:50%;"><p>如图所示：</p><img src="/b6f9ab9c/image-20200410133936036.png" alt="image-20200410133936036" style="zoom:50%;"><p>事实上很少有使用头插法的，因为自古以来都是“先来后到之说”。</p><p>尾插法代码如下：</p><img src="/b6f9ab9c/3.11.jpg" style="zoom:50%;"><p>流程图如下：</p><img src="/b6f9ab9c/image-20200410134614497.png" alt="image-20200410134614497" style="zoom:50%;"><h4 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h4><p>单链表整表删除的算法思路如下：</p><ul><li>声明一个结点<code>p</code>和<code>q</code>；</li><li>将第一个结点赋值给<code>p</code>；</li><li>循环：<ul><li>将下一个结点赋值给<code>q</code>；</li><li>释放<code>p</code>；</li><li>将<code>q</code>赋值给<code>p</code>；</li></ul></li></ul><p>实现代码如下：</p><img src="/b6f9ab9c/image-20200410135040331.png" alt="image-20200410135040331" style="zoom:50%;"><p><strong>代码中的<code>q</code>不能去除</strong>，因为<code>q</code>相当于寄存<code>p</code>结点后继结点的容器，若直接删除<code>p</code>而没有<code>q</code>会导致无法知道后继是谁，造成无法删除。</p><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><img src="/b6f9ab9c/image-20200410135648819.png" alt="image-20200410135648819" style="zoom:50%;"><ul><li>总之，若线性表中的元素个数变化较大，需要频繁的插入和删除操作时，宜采用单链表结构，反之对于知道数组大小，而且很少插入和删除的操作时宜采用顺序存储结构的线性表。</li></ul><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p><strong>静态链表主要是针对没有指针的语言，了解它更多的取其思想之精华，以为日后之借鉴。</strong></p><p>对于没有指针的语言来说，就不能像单链表一样通过指针域来进行链接。但是大佬就是大佬，他们提出使用数组来代替指针。</p><p>让数组的每个元素都是由两个数据域组成，<code>data</code>和<code>cur</code>。数组的每个下标都对应一个<code>data</code>和一个<code>cur</code>。<code>cur</code>叫做游标，相当于单链表中的next指针，存放后继元素中的数组下标。</p><p>通常对数组中第一个和最后一个元素，不存数据。</p><img src="/b6f9ab9c/3.12.jpg" style="zoom:50%;"><p>数组的第一个元素的<code>cur</code>存放备用链表的第一个结点的下标；最后一个元素的<code>cur</code>存放第一个有数值的元素的下标，相当于单链表中的头结点。</p><p>初始化的空的静态链表代码如下：</p><img src="/b6f9ab9c/image-20200410141849219.png" alt="image-20200410141849219" style="zoom:50%;"><h4 id="静态链表的插入"><a href="#静态链表的插入" class="headerlink" title="静态链表的插入"></a>静态链表的插入</h4><p>为了找到数组中哪些分量未被使用，通过将所有未被使用过的以及删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入得新节点。</p><p>返回待插入结点得下标代码：</p><img src="/b6f9ab9c/image-20200410142806293.png" alt="image-20200410142806293" style="zoom:50%;"><p>插入第i个元素的代码如下：</p><img src="/b6f9ab9c/image-20200410143030586.png" alt="image-20200410143030586" style="zoom:50%;"><img src="/b6f9ab9c/image-20200410143502306.png" alt="image-20200410143502306" style="zoom:50%;"><h4 id="静态链表的删除"><a href="#静态链表的删除" class="headerlink" title="静态链表的删除"></a>静态链表的删除</h4><img src="/b6f9ab9c/image-20200410155117543.png" alt="image-20200410155117543" style="zoom:50%;"><p>释放结点的实现代码：</p><img src="/b6f9ab9c/image-20200410162351065.png" alt="image-20200410162351065" style="zoom:50%;"><p>其中<code>Free_SSL(L, j)</code>为：</p><img src="/b6f9ab9c/image-20200410161553053.png" alt="image-20200410161553053" style="zoom:50%;"><img src="/b6f9ab9c/image-20200410155117543.png" alt="image-20200410155117543" style="zoom:50%;"><h4 id="静态链表的长度"><a href="#静态链表的长度" class="headerlink" title="静态链表的长度"></a>静态链表的长度</h4><p>实现代码：</p><img src="/b6f9ab9c/image-20200410162848974.png" alt="image-20200410162848974" style="zoom:50%;"><p>根据下面这个图就明白了：</p><img src="/b6f9ab9c/image-20200410163203790.png" alt="image-20200410163203790" style="zoom:50%;"><p><code>i</code>的初始值为<code>1</code>，然后一直循环，知道最后一个元素的cur值为0，即<code>i=0</code>后跳出循环，通过计数<code>j</code>得出元素的个数。</p><h4 id="静态链表的优缺点"><a href="#静态链表的优缺点" class="headerlink" title="静态链表的优缺点"></a>静态链表的优缺点</h4><img src="/b6f9ab9c/image-20200410163553225.png" alt="image-20200410163553225" style="zoom:50%;"><p>总上可知，静态链表主要是针对没有指针的语言。对于有指针的语言，不会用到它的。主要是学习其思想。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。</p><img src="/b6f9ab9c/image-20200410164234277.png" alt="image-20200410164234277" style="zoom:50%;"><p>循环链表和单链表的主要<strong>差异在循环的判断条件</strong>上：</p><ul><li>单链表是判断<code>p-&gt;next</code>是否为空，来判断是否停止；</li><li>循环链表是判断<code>p-&gt;next</code>是否等于头结点，来判断是否循环结束；</li></ul><p>将两个循环链表合并：</p><img src="/b6f9ab9c/image-20200410164737635.png" alt="image-20200410164737635" style="zoom:50%;"><p><img src="/b6f9ab9c/image-20200410164807110.png" alt="image-20200410164807110"></p><p>只需要执行以下代码即可实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = rearA-&gt;next;            <span class="comment">//保留A的头，即①</span></span><br><span class="line">rearA-&gt;next = rearB-&gt;next-&gt;next; <span class="comment">// 即A的尾指针指向B的第一个结点,即②</span></span><br><span class="line">rearB-&gt;next = p; <span class="comment">// B的尾指针指向A头结点，形成循环链表，即③</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// p是新建的一个指针，用完后要及时释放，否则可能会内存泄漏和占用            //内存</span></span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>为了克服链表单向性这一缺点，<strong>在单链表的每个结点中，再设置一个指向其前驱结点的指针域，形成双向链表</strong>。</p><p>双向循环链表：</p><img src="/b6f9ab9c/image-20200410170503719.png" alt="image-20200410170503719" style="zoom:50%;"><p><code>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next</code>这应该很好理解吧！</p><p>双向链表很多都是由单向链表扩展的，基本操作大同小异。但是在插入操作时要<strong>注意顺序</strong>，千万不能反了。</p><img src="/b6f9ab9c/image-20200410170906257.png" alt="image-20200410170906257" style="zoom:50%;"><img src="/b6f9ab9c/image-20200410170935055.png" alt="image-20200410170935055" style="zoom:50%;"><p>由于第2步和第3步，都用到了<code>p-&gt;next</code>如果先执行第四步，则使<code>p-&gt;next</code>提前变为<code>s</code>。<strong>顺序使先搞定<code>s</code>的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继</strong>。</p><p>删除操作：</p><img src="/b6f9ab9c/image-20200410171325723.png" alt="image-20200410171325723" style="zoom:50%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><hr><p>感谢阅读:smile:.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬取淘宝商品名称和价格</title>
      <link href="/a4e5e07c.html"/>
      <url>/a4e5e07c.html</url>
      
        <content type="html"><![CDATA[<hr><p>在B站上观看北京理工大学的爬虫慕课，在爬取淘宝商品价格和名称时出现了只出表头信息的结果。</p><a id="more"></a><p><img src="/a4e5e07c/p1.png" alt></p><p>经过在视频下方评论区的方法发现依然有错，最后发现是自己的拼写错误:joy:</p><p>发话不多说直接上教程：（<strong>我使用的是chrome浏览器</strong>）</p><p>在淘宝页面右键，点击检查：</p><img src="/a4e5e07c/p2.jpg" style="zoom:50%;"><p>然后在源代码区进行以下步骤：</p><ul><li><p>1、点击<code>Network</code></p></li><li><p>2、刷新页面，点击<code>Name</code>中的第一个<code>search?</code></p></li><li><p>3、在<code>Headers</code>中复制<code>cookie和user-agent</code>内容</p><p> <img src="/a4e5e07c/p3.jpg" alt></p></li></ul><p><strong>把复制的内容放到如下位置：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTML</span><span class="params">(url)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'解析开始'</span>)</span><br><span class="line">        headers = &#123;</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span>,</span><br><span class="line">        <span class="string">'cookie'</span>: <span class="string">'miid=1204848422178730713; thw=cn; cna=/FjUFFH98VYCAbfHca7IzgoX; tracknick=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; tg=0; hng=CN%7Czh-CN%7CCNY%7C156; enc=S9dNZWnBqTugKoqk7f9MpczA8QNKFdbWP8Dab4FEeTI43rFE%2B%2FrwSE7PnLJF%2BRA5yy70RD7m9rnCJyj72bByLg%3D%3D; t=23bd277878acd720dad699e1cc1f655d; cookie2=1266fc62e2cc3c4136c7085328db7985; v=0; _tb_token_=3fe6ee4e766b8; alitrackid=www.taobao.com; lastalitrackid=www.taobao.com; _samesite_flag_=true; sgcookie=EvIOOHQLzH3Oo804wQlio; unb=2278212962; uc3=lg2=VFC%2FuZ9ayeYq2g%3D%3D&amp;nk2=0ryj1fYS8gv0fQ%3D%3D&amp;vt3=F8dBxdAUzLP9Oq23c0M%3D&amp;id2=UUpmlOw4s1nHfg%3D%3D; csg=f123a494; lgc=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; cookie17=UUpmlOw4s1nHfg%3D%3D; dnk=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; skt=a5e20976396f587e; existShop=MTU4NjA4MzcyMA%3D%3D; uc4=id4=0%40U2gsGA%2BPaSbBR0Lnefhgm24jPZLA&amp;nk4=0%400A28Ox7kSTkcIvypO6o%2FqsLX5wQe; _cc_=VT5L2FSpdA%3D%3D; _l_g_=Ug%3D%3D; sg=%E9%A3%9E2f; _nk_=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; cookie1=VAn7B4bWBvYsc6mrUjgaw%2F%2F8dWi4qfHRI6oPI3CZaYI%3D; tfstk=c47CBgD9vvDCt6DJ59NwYM0dAv8RZXe6sk9dOGUC18n-cLCCix02nXEhqA09DC1..; mt=ci=3_1; JSESSIONID=E9C7BE989C9A4781DC9BDF55EE086724; l=dBLuPSIcqWzW1J7tBOCgqDBHHA7TYIRAgulLJpFvi_5Iw6Y1A2QOo1N4MFv6cjWft28B4z6vzNe9-etlsn4pJA--g3fydxDc.; isg=BNDQjY51utpNoGWOeaq5eOihoR4imbTj3pjtcMqhxyv-BXCvcqgLcyd_3c3l1Wy7; uc1=cookie16=U%2BGCWk%2F74Mx5tgzv3dWpnhjPaQ%3D%3D&amp;cookie21=W5iHLLyFeYZ1WM9hVnmS&amp;cookie15=URm48syIIVrSKA%3D%3D&amp;existShop=false&amp;pas=0&amp;cookie14=UoTUPOT6s4ShJw%3D%3D&amp;tag=8&amp;lng=zh_CN'</span>,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">        h = requests.get(url, headers = headers)</span><br><span class="line">        h.raise_for_status()</span><br><span class="line">        h.encoding = h.apparent_encoding</span><br><span class="line">        <span class="comment">#print(h.text)</span></span><br><span class="line">        <span class="keyword">return</span> h.text</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'html解析失败'</span></span><br></pre></td></tr></table></figure><p>修改划线位置，把自己的user-agent和cookie粘贴即可。</p><p><img src="/a4e5e07c/p4.jpg" alt></p><p>至此，若代码没有拼写等低级错误就会成功输出正确信息。</p><p><img src="/a4e5e07c/p5.jpg" alt></p><p>我自己就是因为<u><strong>拼写错误</strong></u>只输出了表头。</p><p><img src="/a4e5e07c/p6.jpg" alt></p><hr><p>另外一个检查错误的技巧就是巧用print（）函数，来检查代码执行到哪里出错，以及是否输出正确信息。我就是通过这个方法一步步查找到<code>plt</code>得到的返回值为零，然后发现<code>price</code>拼写错误了。</p><hr><p>谢谢阅读:happy:</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各板块透明度设置（无坑版）</title>
      <link href="/undefined.html"/>
      <url>/undefined.html</url>
      
        <content type="html"><![CDATA[<p>在网上找了各种修改透明度的教程，一路踩坑终于调整成功！特此总结防止入坑。</p><a id="more"></a><p>效果预览：<a href="https://zeroflycui.github.io" target="_blank" rel="noopener">https://zeroflycui.github.io</a></p><h1 id="文章主题以及评论区透明度设置"><a href="#文章主题以及评论区透明度设置" class="headerlink" title="文章主题以及评论区透明度设置"></a>文章主题以及评论区透明度设置</h1><p>首先找到此路径  \blog\themes\next\source\css_schemes\Gemini 下的index.styl 文件。</p><img src="/undefined/路径1.jpg" style="zoom:50%;"><p>打开index.styl文件，把 .post-block 下的background后的改为rgba(255,255,255,0.6), 最后的数值是透明度设置，自己调整。</p><img src="/undefined/设置1.jpg" style="zoom:50%;"><p>效果：</p><img src="/undefined/背景透明度2.jpg" style="zoom:50%;"><h1 id="侧边栏透明度设置"><a href="#侧边栏透明度设置" class="headerlink" title="侧边栏透明度设置"></a>侧边栏透明度设置</h1><p>打开以下路径 \blog\themes\next\source\css_schemes\Pisces 下的_sidebar.styl,修改 .sidebar以及.sidebar-inner 下的background：rgba(255,255,255,0.6).如下图所示：</p><img src="/undefined/设置2.jpg" style="zoom:50%;"><p>效果图：</p><img src="/undefined/设置3.jpg" style="zoom:50%;"><hr><p>修改完成，如果有错请通知。谢谢阅读！！</p><p>参考博文链接：</p><p><a href="http://www.aomanhao.top/2019/01/20/theme_NextConfig1/" target="_blank" rel="noopener">http://www.aomanhao.top/2019/01/20/theme_NextConfig1/</a></p><p><a href="https://blog.csdn.net/qq_43414603/article/details/104113198" target="_blank" rel="noopener">https://blog.csdn.net/qq_43414603/article/details/104113198</a></p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
            <tag> 透明度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
