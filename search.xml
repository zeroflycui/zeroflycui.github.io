<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图</title>
      <link href="/ee040603.html"/>
      <url>/ee040603.html</url>
      
        <content type="html"><![CDATA[<hr><hr><p>图是由顶点（vertex）的<strong>有穷非空集合</strong>和顶点之间的边（edge）的集合组成。</p><h1 id="图的定义与术语"><a href="#图的定义与术语" class="headerlink" title="图的定义与术语"></a>图的定义与术语</h1><h2 id="无向图："><a href="#无向图：" class="headerlink" title="无向图："></a><strong>无向图：</strong></h2><img src="/ee040603/image-20200430105923334.png" alt="image-20200430105923334" style="zoom:50%;"><p>任意两个顶点之间的边没有方向，则称这条边为无向边，由无向边组成的图称为无向图。</p><p>无向边用无序偶对 <img src="/ee040603/image-20200430111911606.png" alt="image-20200430111911606" style="zoom: 50%;">来表示。</p><h2 id="有向图："><a href="#有向图：" class="headerlink" title="有向图："></a><strong>有向图：</strong></h2><img src="/ee040603/image-20200430112047552.png" alt="image-20200430112047552" style="zoom:50%;"><p>有向图：任意一条边都是有方向的，则这条边是有向边，也成为弧（Arc），这样的图称为有向图。</p><p>有向边通过有序偶&lt;vi, vj&gt;来表示。其中<code>vi</code>称为弧尾，<code>vj</code>称为弧头。 </p><h2 id="简单图："><a href="#简单图：" class="headerlink" title="简单图："></a><strong>简单图：</strong></h2><p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。</p><img src="/ee040603/image-20200430143132339.png" alt="image-20200430143132339" style="zoom:50%;"><p>上图就不是简单图。</p><h2 id="完全图："><a href="#完全图：" class="headerlink" title="完全图："></a><strong>完全图：</strong></h2><p><strong>无向图</strong>中任意两个顶点之间都存在边，则称为无向完全图。n个顶点含有<img src="/ee040603/image-20200430143513766.png" alt="image-20200430143513766" style="zoom: 33%;"></p><p>条边。</p><p><strong>有向图</strong>中任意两个顶点之间都存在<strong>方向互为相反</strong>的两条弧，则称该图为有向完全图。</p><p>n个顶点含有 <code>n ×（n - 1）</code>条边。</p><p><strong>网：</strong></p><p>图中的边或弧带有相关的数叫做权（weight），这种带权的图通常称为网（Network）。</p><img src="/ee040603/image-20200430144357455.png" alt="image-20200430144357455" style="zoom:50%;"><h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a><strong>子图</strong></h2><p><img src="/ee040603/image-20200430144524582.png" alt="image-20200430144524582"></p><p>灰色部分的图是左侧图的<strong>子图</strong>。</p><p><strong>路径的长度是路径上边或弧的数目。</strong></p><p><strong>第一个顶点到最后一个顶点相同的路径称为回路或环。</strong>序列中除了第一个和最后一个顶点之外，<strong>其他顶点不重复出现</strong>的回路，称为简单回路或简单环。</p><p>序列中顶点不重复出现的路径称为简单路径。</p><img src="/ee040603/image-20200430150658182.png" alt="image-20200430150658182" style="zoom:50%;"><h2 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h2><p>图中<strong>任意</strong>两个顶点之间都有路径的图，称为连通图（Connected Graph）。<strong>无向图</strong>称为<strong>连通图</strong>；<strong>有向图</strong>称为<strong>强连通图</strong>。</p><p>图中的<strong>极大连通子图</strong>称为连通分量。<strong>无向图</strong>称为连通分量；<strong>有向图</strong>称为<strong>强连通分量。</strong></p><p>需要注意的是：</p><ul><li>必须是子图</li><li>子图必须是连通的</li><li>连通子图含有极大的顶点数，以及依附于这些顶点的所有边</li></ul><h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>连通图的生成树是一个<strong>极小的连通子图</strong>，它含有图中全部的<strong><code>n</code>个顶点</strong>，但只有足以构成一棵树的 <strong><code>n-1</code> 条边</strong>。</p><p>由此可知，当含有<code>n</code>个顶点，但是边的条数小于<code>n - 1</code>时，则是非连通图；但是如果多于<code>n-1</code>条边，必定构成一个环。</p><p><strong>但是含有<code>n-1</code>条表的图，不一定是生成树。</strong></p><img src="/ee040603/image-20200430153622194.png" alt="image-20200430153622194" style="zoom:50%;"><p>图2，图3是图1的最小生成树，但是图4尽管含有<code>n-1</code>条边的条件，但是它<strong>不是生成树。</strong></p><p>有向树：</p><p>若一个<strong>有向图恰有一个顶点的入度为0，其余顶点的入度为1</strong>，则是一棵有向树。</p><p>一棵有向树的生成森林由若干棵有向树组成，含有图中全部顶点，但<strong>只有足以构成若干棵不相交的有向树的弧</strong>。</p><img src="/ee040603/image-20200430155144479.png" alt="image-20200430155144479" style="zoom:50%;"><p>图2和图3是图1的两棵有向树（<strong>只是一种情况</strong>）其中由有向树的定义可知，B与A,C要在一起，F要和E,G在一起。</p><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此不能通过使用内存中的物理位置来表示元素之间的关系。但是幸运的是前人已经提出了五种不同的解决办法。</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>图是由顶点和边或弧两部分组成的，为了方便，分别表示边（弧）和顶点。</p><p>因为顶点不分大小主次，所以用一个一维数组存储。</p><p>边（弧）是由两个顶点决定的，因此需要一个二位数组来存储。</p><p>于是提出了<strong>邻接矩阵（Adjacency Matrix）</strong>的概念。</p><p><strong>图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组存储图中的边或弧的信息。</strong></p><p>图中有<code>n</code>个顶点，则二维邻接矩阵是一个<code>n×n</code>的方阵，<img src="/ee040603/image-20200430163226350.png" alt="image-20200430163226350" style="zoom:33%;"></p><img src="/ee040603/image-20200430163304399.png" alt="image-20200430163304399" style="zoom:50%;"><p>通过这个邻接矩阵可以知道以下信息：</p><ul><li>判断任意两个顶点是否有边无边就非常容易</li><li>可以通过特定顶点在邻接矩阵中相应的行（列）的元素之和就可以判断此顶点的度。</li><li>求特定顶点的邻接点，只要遍历邻接矩阵中相应行元素，值为1就是邻接点。</li></ul><img src="/ee040603/image-20200430163915816.png" alt="image-20200430163915816" style="zoom:50%;"><p>对于有向图，同样也可以通过邻接矩阵，<strong>得到特定顶点的入度、出度以及邻接点等信息</strong>。</p><p>对于<strong>网</strong>来说，就需要额外的考虑与边相关的权值了。</p><p>相应的邻接矩阵计算公式如下：</p><img src="/ee040603/image-20200430165024863.png" alt="image-20200430165024863" style="zoom:50%;"><img src="/ee040603/image-20200430165240535.png" alt="image-20200430165240535" style="zoom:50%;"><p>对于<code>n</code>个顶点和<code>e</code>条边的无向网图的创建，<strong>时间复杂度</strong>为<code>O(n＋n^2+e)</code>其中对邻接矩阵的初始化耗费了<code>O(n^2)</code>的时间。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><img src="/ee040603/image-20200430171931057.png" alt="image-20200430171931057" style="zoom:50%;"><p>对于上图来说，使用邻接矩阵来说就存在存储空间的极大浪费。</p><p>因此考虑对边或弧使用<strong>链式存储</strong>的方式来避免空间的浪费问题。</p><p>通过使用数组来存储顶点信息，使用链表的形式来存储边或弧的信息的存储方式，称作<strong>邻接表（Adjacency List）</strong></p><p>邻接表的处理办法：</p><ul><li>图中的顶点用一个一维数组存储，同时，每个数据元素还需要存储指向第一个邻接点的指针，以便查找该顶点的边信息。</li><li>每个顶点的所有邻接点构成一个线性表，由于邻接点的个数不确定，因此可以使用单向链表来存储，<strong>无向图</strong>称为<strong>顶点的边表</strong>，<strong>有向图</strong>称为<strong>顶点作为弧尾的出边表</strong>。</li></ul><img src="/ee040603/image-20200430175019487.png" alt="image-20200430175019487" style="zoom:50%;"><p>但是由于有向图是有方向的，以顶点为弧尾来存储边表，这样就可以得到一个以顶点为弧尾的出边表；同时可以顶点为弧头来存储边表，可以得到一个以顶点为弧头的入边表，称作有向图的逆邻接表。</p><img src="/ee040603/image-20200430180927150.png" alt="image-20200430180927150" style="zoom:50%;"><p>对于带权值得网图：</p><img src="/ee040603/image-20200430181008980.png" alt="image-20200430181008980" style="zoom:50%;"><p>创建邻接表得时间复杂度为<code>O(n+e)</code>.</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>对于有向图来说，当使用邻接表时，当查找了出度问题，若想要了解入度则必须重新遍历整个图才能知道。反之，逆邻接表也有同样问题。为了解决这个问题，提出了<strong>十字链表（Orthogonal List）</strong>。</p><p>重新定义顶点表：</p><img src="/ee040603/image-20200430184522775.png" alt="image-20200430184522775" style="zoom: 80%;"><p><code>firstin</code> 表示入边表头指针，指向该顶点得入边表中第一个结点；<code>firstout</code>表示出边表头指针，指向该顶点得出边表中得第一个结点。</p><p>重定义得边表结点结构：</p><img src="/ee040603/image-20200430184933348.png" alt="image-20200430184933348" style="zoom:80%;"><p><code>tailvex</code>指弧起点在顶点表得下标，<code>headvex</code>表示弧终点在顶点表中得下标，<code>headlink</code>指入边表指针域，指向终点相同得下一条边，<code>taillink</code>是指边表指针域，指向起点相同得吓一条边。</p><p><img src="/ee040603/image-20200430185328973.png" alt="image-20200430185328973"></p><p>十字链表中得实线很好理解，就是正常得邻接表。重点是虚线得理解：其中虚线指向得就是以此顶点为弧头的弧，即通过<code>firstin</code>指针域出发，指向以此顶点为弧头的弧，同时若有多条弧进入，则可以通过边表结点中的<code>headline</code>指针域作为<strong>指向同一终点的下一条边</strong>的特性作为跳板，指向其他入弧。</p><p>十字链表的<strong>好处</strong>：</p><p>由于十字链表把邻接表和逆邻接表整合在一起，这样可以很容易求得顶点的出度和入度。十字链表的创建和邻接表的时间复杂度是相同的，因此在有向图中，十字链表是非常好的数据结构模型。</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>在无向图中，若更多关注的是顶点，则选择邻接表是一个不错的选择。但是若选择更多的关注的是<strong>边</strong>则选择邻接表就不是一个明智的选择了，因为当删除某条边后，则需要找到这条边表格结点进行操作，这就会变得麻烦不简洁。可以借鉴十字链表的特点，对边表结点的结构进行改变。</p><p>重新定义的边表结点的结构如下：</p><img src="/ee040603/image-20200430220538244.png" alt="image-20200430220538244" style="zoom:67%;"><p><code>ivex</code>和<code>jvex</code>表示与某条边依附的两个顶点在顶点表中的下标。<code>ilink</code>指向依附顶点<code>ivex</code>的下一条边，<code>jlink</code>指向依附顶点<code>jvex</code>的下一条边。这就是<strong>多重表结构</strong>。</p><p><img src="/ee040603/image-20200430220943312.png" alt="image-20200430220943312"></p><p>邻接多重表和邻接表的差别，仅仅在于<strong>同一条边在邻接表中用两个节点表示，而在邻接多重表中只有一个结点。</strong></p><p>若删除某条边，只需让相应的指针指向空即可，完成删除操作。</p><h2 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h2><p>边集数组是由两个一维数组构成。一个存储顶点的信息；另一个存储边的信息，这个边数组每个数据元素由一条边的起点下标、终点下标和权值构成。</p><img src="/ee040603/image-20200430222827311.png" alt="image-20200430222827311" style="zoom: 80%;"><p>边集数组<strong>关注的是变得集合</strong>，在边集数组中若要查找某个顶点的度需要扫描整个边数组，效率并不高。因此它<strong>更适合对边依次进行处理的操作，而不适合对顶点相关操作</strong>。</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>深度优先遍历（Depth_First_Search），也称为深度优先搜索，简称为DFS。</p><p>深度优先遍历就是从图中某个顶点<code>v</code>出发，访问此顶点，然后从<code>v</code>的未被访问的邻接点出发深度优先遍历图，直至图中所有和<code>v</code>有路径相同的顶点都被访问到。</p><p><strong>对于非连通图来说</strong>，只需对图中各个连通图依次进行深度优先遍历。</p><p><strong>邻接矩阵</strong>的深度优先遍历代码操作：</p><p><img src="/ee040603/image-20200501080222693.png" alt="image-20200501080222693"></p><p>对于<strong>邻接表</strong>的深度优先遍历：</p><p><img src="/ee040603/image-20200501080425932.png" alt="image-20200501080425932"></p><p>两种不同存储结构的深度优先遍历算法，由于邻接矩阵要查找每个顶点，需要访问矩阵中的所有元素，因此时间复杂度为<code>O(n^2)</code>；而邻接表查找某个顶点，需要的时间取决于顶点和边的数量，时间复杂度为<code>O(n+e)</code>,故当点多边少的图来说，邻接表存储结构的深度遍历时间效率更高。</p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>广度优先遍历（Breadth_First_Search），又称为广度优先搜索，简称BFS。</p><p>广度优先遍历，即将确定开始的顶点作为第一层，与之相邻的顶点作为第二层，以此类推，把全部顶点按照层次从新排列，然后对每一层进行遍历。</p><img src="/ee040603/image-20200501091550820.png" alt="image-20200501091550820" style="zoom:50%;"><p><strong>邻接矩阵</strong>的广度优先遍历：</p><p><img src="/ee040603/image-20200501092100389.png" alt="image-20200501092100389"></p><p>时间复杂度为<code>O(n^2)</code>。</p><p><strong>邻接表</strong>广度优先遍历：</p><p><img src="/ee040603/image-20200501093834170.png" alt="image-20200501093834170"></p><p>时间复杂度为<code>O(n+e)</code>，因为程序中的<code>while(p)</code>模块只有在<code>for() i=0</code>时执行一次，然后就不再执行了，只剩<code>for()</code>执行<code>n-1</code>次结束。</p><p>由此可以看出深度优先遍历和广度优先遍历算法在时间复杂度上是一样的。</p><p><strong>深度优先遍历更适合目标明确，为找到目标为目的的情况；而广度优先遍历更适合不断扩大范围时寻找最优解的情况</strong></p><h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="有环图应用"><a href="#有环图应用" class="headerlink" title="有环图应用"></a>有环图应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>把连通网图中由<code>n</code>个顶点和<code>n-1</code>条边组成的极小连通子图（也称为生成树），把其中最小代价（权值和）生成树称为最小生成树（Minimum Cost Spanning Tree）。</p><h4 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h4><p>Prim算法的操作代码如下：</p><p><img src="/ee040603/image-20200501110325626.png" alt="image-20200501110325626"></p><p>其中17~25行代码，循环当前的<code>lowcost</code>数组，找到最小权值<code>min</code>以及最小权值下标<code>k</code>。</p><p>28~35行代码，判断以<code>k</code>为顶点的邻接顶点的权值与<code>lowcost</code>数组中相应的权值大小，若小则替代<code>lowcost</code>数组中对应的权值，完成<code>lowcost</code>数组的更新；并将<code>adjvex</code>数组中相应下标的值改为<code>k</code>，完成<code>adjvex</code>数组的一次更新。</p><p>Prim算法的时间复杂度为<code>o(n^2)</code>.</p><p><img src="/ee040603/image-20200501112456945.png" alt="image-20200501112456945"></p><h4 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h4><p>Prim算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树。</p><p>也可以直接以变为目的去建立最小生成树，即直接寻找权值最小的边来构建最小生成树。但是要考虑是否形成环路。</p><p>因此用到了图存储结构中的<strong>边集数组</strong>，把边集数组按照权值的大小进行排序。</p><img src="/ee040603/image-20200501114032587.png" alt="image-20200501114032587" style="zoom:50%;"><p>Kruskal算法的操作代码：</p><p><img src="/ee040603/image-20200501115746082.png" alt="image-20200501115746082"></p><p>其中最重要的是<code>19~25</code>的查找代码，准确的算出，<code>n和m</code>的值。</p><p><img src="/ee040603/image-20200501120244904.png" alt="image-20200501120244904"></p><p>函数<code>Find</code>的时间复杂度为<code>O(loge)</code>，因此，kruskal算法的时间复杂度为<code>O(eloge)</code></p><p><strong>对比：</strong></p><p>kruskal算法主要是<strong>针对边</strong>来展开，边数少时效率会非常高，对<strong>稀疏图</strong>有很大优势；prim算法对于<strong>稠密图</strong>，即边非常多的情况会更好。</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>在网图和非网图中，最短路径的含义是不同的。由于<strong>非网图</strong>它没有边上的权值，最短路径是指<strong>两顶点之间经过的边数最少路径</strong>；对于<strong>网图</strong>来说，最短路径，是指两顶点之间经过的<strong>边上权值之和</strong>最少的路径，并且称第一个点为源点，最后一个顶点为终点。</p><h4 id="迪杰斯特拉（Dijkstra）算法"><a href="#迪杰斯特拉（Dijkstra）算法" class="headerlink" title="迪杰斯特拉（Dijkstra）算法"></a>迪杰斯特拉（Dijkstra）算法</h4><p>Dijkstra算法是一个基于之前最短路径长度递增的次序，从而产生最短路径的算法。</p><img src="/ee040603/image-20200501182818488.png" alt="image-20200501182818488" style="zoom:50%;"><p>Dijkstra算法的操作代码：</p><p><img src="/ee040603/image-20200501182954891.png" alt="image-20200501182954891"></p><p>其实这个Dijkstra算法的操作思路和最小生成树中的Prim算法是一样的。都是以<code>v0</code>相关的权值信息来初始化数组（具体数组的功能不同）。</p><p><code>final[]</code>数组是用来标记是否已经遍历过某顶点了。<code>P[]</code>数组存储当前最小距离的顶点下标。<code>D[]</code>数组存储当前的最小路径。</p><p>17~23行代码，表示寻找数组<code>D[]</code>中的最小值<code>min</code>，并令最小值的下标令为<code>k</code>。</p><p>25~32行代码，表示遍历以<code>vk</code>为顶点的邻接边的权值，通过比较之前得到的最短路径<code>min</code>与<code>vk</code>邻接边<code>w</code>权值之和与数组<code>D[w]</code>相比较，将较小的值替换掉数组<code>D[w]</code>中的值。同时更新数组<code>P[w]</code>中的值为<code>k</code>。</p><p>Dijkstra算法的时间复杂度为<code>O[n^2]</code>。</p><p>Dijkstra算法<strong>解决了从某个源点到其余各顶点的最短路径问题</strong>，它的局限性就是只能求取特定源点的最短路径。</p><h4 id="弗洛伊德（Floyd）算法"><a href="#弗洛伊德（Floyd）算法" class="headerlink" title="弗洛伊德（Floyd）算法"></a>弗洛伊德（Floyd）算法</h4><img src="/ee040603/image-20200501220553423.png" alt="image-20200501220553423" style="zoom: 80%;"><p>Floyd算法的操作代码：</p><p><img src="/ee040603/image-20200501220918696.png" alt="image-20200501220918696"></p><p>由于所求的是<strong>所有顶点到所有顶点的最短路径</strong>，因此数组<code>P[]、D[]</code>都是二维数组。</p><p>Floyd算法的核心就是，遍历数组<code>D[]</code>中的元素的权值，同时与以各个顶点为跳转点的路径权值做对比，将较小的一组值保留在数组<code>D[]</code>中，同时更改数组<code>P[]</code>中的值（<code>P[v][w]=k</code>k是跳转顶点下标）。</p><p>经过上述代码，可以得到如下数组矩阵：</p><p><img src="/ee040603/image-20200501221857239.png" alt="image-20200501221857239"></p><p>通过这两个数组，可以求出<strong>所有顶点到所有顶点的最短路径权值</strong>。</p><p>求任意最短路径的操作代码：</p><img src="/ee040603/image-20200501222629450.png" alt="image-20200501222629450" style="zoom:80%;"><p>通过代码可知，时间复杂度为<code>O(n^3)</code></p><p>当面临<strong>求所有顶点到所有顶点的最短路径</strong>时，Floyd算法是个不错的选择。</p><h2 id="无环图应用"><a href="#无环图应用" class="headerlink" title="无环图应用"></a>无环图应用</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的<strong>有向图为顶点表示活动的网</strong>，这称之为AOV网（Activity On Vertex Network）AOV网中的<strong>弧表示活动之间存在某种制约关系。</strong></p><p>图<code>G</code>是一个具有<code>n</code>个顶点的有向图，<code>V</code>中的顶点序列<code>v1,v2,……,vn</code>,满足若从顶点<code>vi</code>到<code>vj</code>有一条路径，则在顶点序列中顶点<code>vi</code>必须在顶点<code>vj</code>之前，则称这样的<strong>顶点序列</strong>为一个拓扑序列。<strong>拓扑序列不止一条</strong></p><p><strong>拓扑排序，就是对一个有向图构造拓扑序列的过程</strong></p><p>若此网的<strong>全部顶点都被输出</strong>，则说明它是<strong>不存在环的</strong>的AOV网；若<strong>输出顶点少了</strong>，哪怕是少了一个，说明这个<strong>网中存在环</strong> ,不是AOV网。</p><h4 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h4><p>对AOV网进行拓扑排序的<strong>基本思路</strong>是：</p><p><strong>从AOV网中选择一个入度为<code>0</code>的顶点输出，然后删除此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为<code>0</code>的顶点为止。</strong></p><p>由于在拓扑排序中，<strong>需要删除顶点</strong>，显然用<strong>邻接表</strong>会更加方便。</p><p>顶点表结构如下：</p><p><img src="/ee040603/image-20200502085618935.png" alt="image-20200502085618935"></p><p><code>in</code>是<strong>顶点的入度</strong>。</p><img src="/ee040603/image-20200502085901482.png" alt="image-20200502085901482" style="zoom:67%;"><p>在算法中，引入了栈的概念，目的是为了把入度为<code>0</code>的顶点存储到栈中，目的是为了避免每次查找时都要遍历顶点表中有没有入度为<code>0</code>的顶点。</p><p>下面是拓扑排序算法的操作代码：</p><p><img src="/ee040603/image-20200502094518386.png" alt="image-20200502094518386"></p><p>核心代码是12~23行代码，实现了入度为<code>0</code>的顶点压入栈中，以及输出打印栈中顶点，统计输出顶点数以判断是否会存在回环，同时解决了删除相应弧后邻接点的何去何从的问题。</p><p>此算法的时间复杂度为<code>O(n+e)</code>。9<del>11行对各顶点的遍历的时间复杂度为<code>O(n)</code>，12</del>23行代码，主要完成每个顶点按照一定的排序依次输出，换句话说就是，<strong>把每条弧依次删除后，从而得到了顶点的输出顺序</strong>（这只是自己的理解，不对之处还请指教）因次此段代码的时间复杂度为<code>O(e)</code>。因此，此算法的时间复杂度为<code>O(n+e)</code>。</p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种<strong>有向图的边</strong>表示活动的网，称为AOE网（Activity On <strong>Edge</strong> Network）</p><p>在AOE网中，没有入边的顶点称为源点或始点，没有出边的顶点叫做汇点或终点。</p><img src="/ee040603/image-20200502100600789.png" alt="image-20200502100600789" style="zoom:80%;"><p>AOE网和AOF网还是有区别的，从名字上就可以看出，AOE网更注重<strong><code>Edge</code></strong>;而AOF网更注重的是<strong><code>Vertex</code></strong>，它只描述活动之间的制约关系。 </p><p>把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有<strong>最大长度</strong>的路径叫做<strong>关键路径</strong>，在关键路径上的活动称为<strong>关键活动</strong>（弧）</p><h4 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h4><p>为了获得关键路径，首先要找到所有的关键活动。那么关键活动如何寻找呢？如下：</p><p>找到活动的最早开始时间以及最晚开始时间，若最早和最晚开始时间相等，则说明此活动没有空闲时间，可以作为关键活动；反之说明含有空闲时间，不能作为关键活动。</p><p>定义以下几个参数：</p><ul><li><strong>事件</strong>的最早发生时间<code>etv</code>(earliest time of vertex)：即顶点最早发生时间（）</li><li><strong>事件</strong>的最晚发生时间<code>ltv</code>(latest time of vertex)：即顶点最晚发生时间（）</li><li><strong>活动</strong>最早开工时间<code>ete</code>(earliest time of edge)：即弧的最早发生时间（<strong>在数值上，和事件最早发生时间<code>etv</code>相同</strong>）</li><li><strong>活动</strong>最晚开工时间<code>lte</code>(latest time of edge)：即弧的最晚发生时间（<strong>在数值上，为下一事件开始之前</strong>）</li></ul><p>可以通过<code>etv\ltv</code>求出<code>ete\lte</code>，通过判断<code>ete</code>是否等于<code>lte</code>来判断是否为关键活动。</p><img src="/ee040603/image-20200502103244203.png" alt="image-20200502103244203" style="zoom:67%;"><p>改进后的拓扑排序算法操作代码：</p><p><img src="/ee040603/image-20200502110605267.png" alt="image-20200502110605267"></p><p>主要的改进就是加粗的部分代码，它主要新增了一个栈<code>stack2</code>用来存储输出的拓扑序列。同时求出了<code>etv</code>的数组值。</p><p>可知，计算顶点事件最早发生时间公式如下:</p><p><img src="/ee040603/image-20200502111147877.png" alt="image-20200502111147877"></p><p>因为<code>etv</code>一开始初始化为<code>0</code>，所以当<code>k!=0</code>时就如所给公式中一样了。</p><p>求取关键路径的操作代码：</p><p><img src="/ee040603/image-20200502114137174.png" alt="image-20200502114137174"></p><p>主要时通过求拓扑序列，得到的拓扑路径<code>stack2</code>和事件最早开始时间<code>etv</code>来求取：事件最晚开始时间<code>ltv</code>；活动最早发生时间<code>ete</code>,活动最晚发生时间<code>lte</code>.然后通过判断<code>ete</code>与`lte是否相等来判断关键路活动，从而得到关键路径。</p><p><img src="/ee040603/image-20200502115357898.png" alt="image-20200502115357898"></p><p>在实际工程中，<strong>可能存在多条关键路径</strong>，此时<strong>必须同时提高在几条关键路径上的关键活动速度</strong>。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/6534ce06.html"/>
      <url>/6534ce06.html</url>
      
        <content type="html"><![CDATA[<hr><p><img src="/6534ce06/image-20200428190107477.png" alt="image-20200428190107477"></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><blockquote><p>栈：限定<strong>仅</strong>在表尾进行插入和删除操作的<strong>线性表</strong>。</p></blockquote><p>栈又称为<strong>后进先出</strong>（Last In First Out）线性表，简称LIFO结构。</p><img src="/6534ce06/image-20200425084743968.png" alt="image-20200425084743968" style="zoom:50%;"><p>栈对线性表的插入和删除的位置进行了限制，但是并没有对何时插入与删除进行限制，在<strong>不是所有元素都进栈，并保证栈顶元素出栈的情况下</strong>，先进入的可以不必最后出。</p><h2 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>对于顺序存储结构，可以通过数组来实现。一般将下标为0的一端作为栈底，这样当存入和删除元素时，数组变化最小。定义top变量指代栈顶元素在数组中的位置，但是top变量必须小于数组的长度。<strong>当栈存在一个元素时，top记为0，因此把空栈的top记为-1</strong>.</p><p>假设有5个元素下栈的几种可能情况。</p><img src="/6534ce06/image-20200425095242395.png" alt="image-20200425095242395" style="zoom:50%;"><p>push操作代码：</p><img src="/6534ce06/image-20200425095700751.png" alt="image-20200425095700751" style="zoom:50%;"><p>pop操作代码：</p><img src="/6534ce06/image-20200425095740831.png" alt="image-20200425095740831" style="zoom:50%;"><h4 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h4><p>为了最大程度上利用数组的空间，可以通过将两个<strong>同类型</strong>的栈组合起来，一起共享数组空间。将两个栈底分别作为数组的起始端和末端。如图：</p><img src="/6534ce06/image-20200425101135540.png" alt="image-20200425101135540" style="zoom:50%;"><p>只要top1和top2两个栈顶指针不相遇，两个栈就可以一直使用。</p><blockquote><p>当top1等于-1时，栈1为空；当top2等于n时，栈2为空。</p><p>当栈2为空，top1等于n-1时，栈1满栈；当top2等于0时，栈2满栈。</p></blockquote><p>当两个指针之间相差1时，即 top1 + 1 == top2 时栈是满栈。</p><p>两栈共享空间的push操作代码：</p><img src="/6534ce06/image-20200425104129706.png" alt="image-20200425104129706" style="zoom:50%;"><p>注意，红色部分，++i 与 i++ 的区别。</p><p>pop操作代码：</p><img src="/6534ce06/image-20200425104320630.png" alt="image-20200425104320630" style="zoom:50%;"><p>使用这种数据结构，通常是两个栈的空间需求有相反关系时，即一个栈空间增加而另一个栈空间缩小。</p><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>栈的链式存储结构，可以简称为链栈。</p><p>由于链表含有头指针的单链表头，因此可以通过单链表头作为栈顶。效果图如下：</p><img src="/6534ce06/image-20200425105324677.png" alt="image-20200425105324677" style="zoom:50%;"><p>对于空栈来说，由于空链表定义的头指针指向空，则链栈的空其实就是 top=NULL。</p><p>push操作代码：</p><img src="/6534ce06/image-20200425110352448.png" alt="image-20200425110352448" style="zoom:50%;"><img src="/6534ce06/image-20200425110545084.png" alt="image-20200425110545084" style="zoom:50%;"><p>pop操作：</p><img src="/6534ce06/image-20200425110723458.png" alt="image-20200425110723458" style="zoom:50%;"><img src="/6534ce06/image-20200425110750706.png" alt="image-20200425110750706" style="zoom:50%;"><p>通过链栈和顺序栈的比较可知：<strong>在栈的使用过程中，若使用的元素变化不可预测，时大时小，则最好使用链栈，若知道在可控的范围内，则使用顺序栈更好</strong>。</p><h2 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h2><p>栈的引用，简化了程序设计的问题，划分了不同关注层次，使思考范围缩小，更聚焦当前要解决的问题。数组之类的，还需要分散精力去考虑数组下标增减等细节问题。</p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>定义：<strong>直接调用自己或通过一些列的调用语句间接地调用自己的函数，称作递归函数。</strong></p><p><strong>注意：</strong>递归的最大陷阱就是要防止进入<strong>无限递归</strong>因此在<strong>每个递归定义必须至少有一个条件，满足时递归不再进行。</strong></p><p>运用递归能使程序的<strong>结构更清晰、更简洁、更容易理解，从而减少读懂代码的时间</strong>。但是大量的递归调用会建立函数的副本，会<strong>耗费大量时间和内存</strong>。迭代则不需要反复调用函数和占用额外的内存。</p><p>栈和递归的关系：</p><p>在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址<strong>都被压入栈</strong>中。在退回阶段，位于栈顶的局部变量、参数值和返回地址<strong>被弹出</strong>，用于返回调用层次中执行代码的其余部分，即恢复调用的状态。</p><h3 id="四则运算表达式求值"><a href="#四则运算表达式求值" class="headerlink" title="四则运算表达式求值"></a>四则运算表达式求值</h3><p>后缀表达式规则：</p><p>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。<br>$$<br>9+(3-1)×3+10÷2<br>$$<br>示例:</p><p><img src="/6534ce06/image-20200425180452247.png" alt="image-20200425180452247"></p><p>在平常的四则运算中的表达式叫做中缀表达式。中缀表达式转换为后缀表达式的规则：</p><p><strong>从左到右遍历表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</strong></p><p>想让计算机处理常用的中缀表达式，最重要的是以下两步：</p><ul><li>将中缀表达式转化为后缀表达式（栈用来<strong>进出运算的符号</strong>）</li><li>将后缀表达式进行运算得出结果（栈用来<strong>进出运算的数字</strong>）</li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列（queue）是<strong>只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong></p><p>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为对头。</p><img src="/6534ce06/image-20200426080824944.png" alt="image-20200426080824944" style="zoom:50%;"><h2 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h2><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>队列的顺序存储结构需要建立一个大于n的数组，但是由于队列的特殊性（先进先出）入队操作，只需在数组后加一个元素，不需要移动任何元素，此时复杂度为O(1)。但是，在出队操作时，需要删除数组第一个元素，则需要把<strong>所有</strong>元素都向前移动，此时的时间复杂度为O(n)。</p><img src="/6534ce06/image-20200426083633132.png" alt="image-20200426083633132" style="zoom:50%;"><p>为了避免出队列时，增加时间复杂度，引入两个指针，front指针指向队头元素，rear指针指向队尾元素的<strong>下一个位置</strong>，当front等于rear时，此队列是空队列。</p><img src="/6534ce06/image-20200426084014937.png" alt="image-20200426084014937" style="zoom:50%;"><p>假溢出：在入队时，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，而且<strong>队列的前端还有空闲</strong>，把这种现象称为假溢出。</p><img src="/6534ce06/image-20200426084643305.png" alt="image-20200426084643305" style="zoom:50%;"><p>为了解决假溢出的问题，引入了循环队列：把队列的头尾相接的顺序存储结构称为循环队列。</p><img src="/6534ce06/image-20200426090055084.png" alt="image-20200426090055084" style="zoom:50%;"><p>但此时的问题是：当front指针等于rear指针时，此时队列为空。但是此时，front指针等于rear指针，队列为满。</p><p>那么如何判断当front指针等于rear时，队列是空还是满呢？</p><ul><li>设置一个标志变量flag，当front==rear，且flag = 0时队列为空，当flag=1时队列为满。</li><li>办法二，当队列为空时，条件就是front ==rear，当队列满时，修改其条件，<strong>保留一个元素空间</strong>。</li></ul><img src="/6534ce06/image-20200426092144219.png" alt="image-20200426092144219" style="zoom:50%;"><p>上图即为方法二的满队情况。</p><p>在满队的情况下，rear有可能比front大也可能小。需要通过以下方法来判断队列满。</p><p>设队列的最大尺寸为QueueSize,那么队列满的条件是<strong>(rear+1)%QueueSize == front</strong>.</p><p><strong>通用的队列长度计算公式：</strong>（rear-front + QueueSize）%QueueSize</p><p>循环队列的顺序存储结构代码如下：</p><img src="/6534ce06/image-20200426093308450.png" alt="image-20200426093308450" style="zoom:50%;"><p>循环队列的初始化代码如下：</p><img src="/6534ce06/image-20200426093357676.png" alt="image-20200426093357676" style="zoom:50%;"><p>循环队列求长度代码：</p><img src="/6534ce06/image-20200426093550305.png" alt="image-20200426093550305" style="zoom:50%;"><p>循环队列的入队操作：</p><img src="/6534ce06/image-20200426093644631.png" alt="image-20200426093644631" style="zoom:50%;"><p>循环队列的出队操作：</p><img src="/6534ce06/image-20200426093915183.png" alt="image-20200426093915183" style="zoom:50%;"><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><p> 队列的链式存储结构，其实就是线性表的单链表，只是只能尾进头出，简称为链队列。将头指针指向链队列的头结点，队尾指针指向终端结点。</p><img src="/6534ce06/image-20200426100400135.png" alt="image-20200426100400135" style="zoom:50%;"><p>当队列为空时，头指针和尾指针都指向头结点。</p><img src="/6534ce06/image-20200426100532695.png" alt="image-20200426100532695" style="zoom:50%;"><p>入队操作：</p><p><img src="/6534ce06/image-20200426100623318.png" alt="image-20200426100623318"></p><p><img src="/6534ce06/image-20200426100751336.png" alt="image-20200426100751336"></p><p>出队操作：</p><p><img src="/6534ce06/image-20200426100826898.png" alt="image-20200426100826898"></p><img src="/6534ce06/image-20200426101449339.png" alt="image-20200426101449339" style="zoom:50%;"><p>在可以确定队列长度最大值的情况下，建议用循环队列，若无法预估计队列的长度时，则用链队列。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表笔记之于大话数据结构</title>
      <link href="/b6f9ab9c.html"/>
      <url>/b6f9ab9c.html</url>
      
        <content type="html"><![CDATA[<hr><p>本文主要是通过阅读大话数据结构第三章，总结一些自己对线性表得所得与所想，希望能对您有所帮助，也为方便自己日后查阅。若有错误之处，请大佬指出:happy:</p><a id="more"></a><p><img src="/b6f9ab9c/image-20200410172957516.png" alt></p><h1 id="线性表得定义"><a href="#线性表得定义" class="headerlink" title="线性表得定义"></a>线性表得定义</h1><p><code>定义：零个或多个数据元素的有限序列。</code></p><p>线性表有以下特性：</p><blockquote><p>线性表是个序列。元素之间是<strong><em>有顺序</em></strong>的，除第一个和最后一个，每个元素都<strong>有且只有</strong>一个前驱和后继。</p><blockquote><p>线性表是<strong><em>有限的</em></strong>。</p><p>数据元素的类型是一样的。</p></blockquote></blockquote><h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p>线性链表的抽象数据类型，也就是时说线性表应该有什么样的操作呢。</p><p>线性表的抽象数据类型定义如下：</p><img src="/b6f9ab9c/3.1.jpg" style="zoom:33%;"><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p>顺序存储结构定义：<code>用一段地址连续的存储单元依次存储线性表的数据元素。</code></p><p>线性表的存储示意图如下：</p><img src="/b6f9ab9c/3.2.jpg" style="zoom:33%;"><h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><p>可以通过<strong>一维数组来实现顺序存储结构</strong>。</p><p>线性表的顺序存储的结构代码：</p><p><img src="/b6f9ab9c/3.3.jpg" alt></p><h3 id="数据长度与线性表长度区别"><a href="#数据长度与线性表长度区别" class="headerlink" title="数据长度与线性表长度区别"></a>数据长度与线性表长度区别</h3><p>区别如下：</p><p><img src="/b6f9ab9c/image-20200410094544007.png" alt="image-20200410094544007"></p><h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3><p>由于存储器中的每个存储单元都有自己的编号，即地址。假设每个数据元素都占用一个固定的存储单元c，那么可以得到任意存储位置的地址：<br>$$<br>LOC(a_i)=LOC(a_1)+(i-1)*c<br>$$<br>对顺序存储结构的线性表来说，存入或者取出数据，的时间复杂度都为O(1)。通常把具有这一特点的存储结构称为随机存取结构。</p><h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>要是实现获得数据GetElem操作，只要 i 的数值在数组下标范围内，就是把数组第 <code>i-1</code>下标返回即可。代码如下：</p><p><img src="/b6f9ab9c/3.5.jpg" alt></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>要实现<code>ListInsert(*L,i,e)</code>，即在线性表L中的第i个位置插入新元素e，该如何操作？</p><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表长度大于数组长度，则抛出异常或动态增加容量；</li><li>从<strong>最后一个元素开始向前遍历</strong>到第 <code>i</code> 个位置，分别将它们都向后移动一个位置；</li><li>将要插入的元素填入位置<code>i</code>处；</li><li>表长加1；</li></ul><p>代码实现如下：</p><img src="/b6f9ab9c/3.6.jpg" style="zoom:50%;"><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常；</li><li>取出删除元素；</li><li>从<strong>删除元素位置</strong>，开始遍历到最后一个元素位置，分别将它们都向前移动一个个位置；</li><li>表长减1；</li></ul><p>实现代码如下：</p><p><img src="/b6f9ab9c/3.7.jpg" alt></p><p>插入和删除的时间复杂度都为<code>O(n)</code></p><h4 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h4><p>优缺点总结如下：</p><p><img src="/b6f9ab9c/image-20200410104532727.png" alt="image-20200410104532727"></p><h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><p>线性链表的特点：</p><ul><li>用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这些元素可以在未被占用内存的任意位置。</li></ul><p>链式存储结构的组成部分：</p><ul><li>数据域：用来存储数值信息；</li><li>指针域：用来指向后继元素存储地址的指针。</li></ul><p>把一个元素的指针域和数据域组成的存储映像，称为<strong>节点</strong>。</p><img src="/b6f9ab9c/image-20200410105654619.png" alt="image-20200410105654619" style="zoom:50%;"><p><strong>把链表中第一个节点的存储位置叫做头指针</strong>，整个链表都是从头指针开始进行的。</p><p>最后一个节点的指针为空（通常用<code>NULL</code>或<code>&quot;^&quot;</code>表示）。</p><img src="/b6f9ab9c/image-20200410110627268.png" alt="image-20200410110627268" style="zoom:50%;"><p>通常在第一个节点前添加一个头节点。头节点的数据域可以为空，也可以存储线性表的长度等附加信息。</p><p>头节点和头指针的区别：</p><img src="/b6f9ab9c/image-20200410112358275.png" alt="image-20200410112358275" style="zoom:50%;"><p>通过下图可更加直观的明白头指针和头结点大的区别：</p><img src="/b6f9ab9c/3.8.jpg" style="zoom:50%;"><p>假设<code>p</code>是指向线性表的第<code>i</code>个元素的指针，该结点的数据域为<code>p-&gt;data</code>值是一个数据元素，指针域为<code>p-&gt;next</code>是一个指针。</p><img src="/b6f9ab9c/image-20200410113228723.png" alt="image-20200410113228723" style="zoom:50%;"><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><p>获得链表第<code>i</code>个数据的算法思路：</p><ul><li>声明一个结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从<code>1</code>开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让<code>p</code>的指针向后移动，不断指向下一个结点，<code>j</code>累加1；</li><li>若到链表末尾<code>p</code>为空，则说明第<code>i</code>个元素不存在；</li><li>否则查找成功，返回结点<code>p</code>的数据；</li></ul><p>实现代码为：</p><img src="/b6f9ab9c/3.9.jpg" style="zoom:50%;"><p>简单说就是从头开始遍历，直到第<code>i</code>个元素为止。此时的时间复杂度，最差为<code>O(n)</code></p><h4 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h4><img src="/b6f9ab9c/image-20200410115837689.png" alt="image-20200410115837689" style="zoom:50%;"><p>要把<code>s</code>结点插入，则只需，<code>s-&gt;next=p-&gt;next</code>和<code>p-&gt;next=s</code>即可。切记这<strong>两句命令不能顺序颠倒</strong>。把p的后继结点改为s的后继结点，再把结点s改成p的后继结点。</p><p>在表头和表尾的插入操作：</p><img src="/b6f9ab9c/image-20200410120406379.png" alt="image-20200410120406379" style="zoom:50%;"><p>单链表第i个数据插入结点的算法思路：</p><ul><li>声明一个结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从1开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让<code>p</code>的指针向后移动，不断指向下一结点，<code>j</code>累加1；</li><li>若到链表末尾<code>p</code>为空，则说明第<code>i</code>个元素不存在；</li><li>否则查找成功，在系统中生成一个空结点s；</li><li>将数据元素<code>e</code>赋值给<code>s-&gt;data</code>；</li><li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next; p-&gt;next=s;</code>;</li><li>返回成功；</li></ul><p>代码如下：</p><img src="/b6f9ab9c/image-20200410130928070.png" alt="image-20200410130928070" style="zoom:50%;"><h4 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h4><img src="/b6f9ab9c/image-20200410131049102.png" alt="image-20200410131049102" style="zoom:50%;"><p>只需要做<code>p-&gt;next=p-&gt;next-&gt;next</code>,即可。令<code>q=p-&gt;next</code>。</p><p>单链表删除的算法步骤：</p><ul><li>声明一结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从<code>1</code>开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，<code>j</code>累加1；</li><li>若链表末尾p为空，则说明第 i 个元素不存在；</li><li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li><li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>;</li><li>将<code>q</code>结点中的数据赋值给<code>e</code>，作为返回；</li><li>释放<code>q</code>结点；</li><li>返回成功；</li></ul><p>实现代码如下：</p><img src="/b6f9ab9c/image-20200410131903592.png" alt="image-20200410131903592" style="zoom:50%;"><h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><p>创建单链表的过程是一个动态生成链表的过程，即从空表的初始状态，依次建立各元素结点，并逐个插入链表。</p><p>头插法：</p><p>单链表整表创建的算法思路：</p><ul><li>声明一个结点<code>p</code>和计数器变量<code>i</code>;</li><li>初始化一个空链表L；</li><li>让<code>L</code>的头结点的指针指向NULL,即建立一个带头结点的单链表；</li><li>循环：<ul><li>生成一个新节点赋值给<code>p</code>；</li><li>随机生成一个数字赋值给<code>p</code>的数据域<code>p-&gt;data</code>；</li><li>将<code>p</code>插入到头结点与之前新一结点之间；</li></ul></li></ul><p>代码实现如下：</p><img src="/b6f9ab9c/3.10.jpg" style="zoom:50%;"><p>如图所示：</p><img src="/b6f9ab9c/image-20200410133936036.png" alt="image-20200410133936036" style="zoom:50%;"><p>事实上很少有使用头插法的，因为自古以来都是“先来后到之说”。</p><p>尾插法代码如下：</p><img src="/b6f9ab9c/3.11.jpg" style="zoom:50%;"><p>流程图如下：</p><img src="/b6f9ab9c/image-20200410134614497.png" alt="image-20200410134614497" style="zoom:50%;"><h4 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h4><p>单链表整表删除的算法思路如下：</p><ul><li>声明一个结点<code>p</code>和<code>q</code>；</li><li>将第一个结点赋值给<code>p</code>；</li><li>循环：<ul><li>将下一个结点赋值给<code>q</code>；</li><li>释放<code>p</code>；</li><li>将<code>q</code>赋值给<code>p</code>；</li></ul></li></ul><p>实现代码如下：</p><img src="/b6f9ab9c/image-20200410135040331.png" alt="image-20200410135040331" style="zoom:50%;"><p><strong>代码中的<code>q</code>不能去除</strong>，因为<code>q</code>相当于寄存<code>p</code>结点后继结点的容器，若直接删除<code>p</code>而没有<code>q</code>会导致无法知道后继是谁，造成无法删除。</p><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><img src="/b6f9ab9c/image-20200410135648819.png" alt="image-20200410135648819" style="zoom:50%;"><ul><li>总之，若线性表中的元素个数变化较大，需要频繁的插入和删除操作时，宜采用单链表结构，反之对于知道数组大小，而且很少插入和删除的操作时宜采用顺序存储结构的线性表。</li></ul><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p><strong>静态链表主要是针对没有指针的语言，了解它更多的取其思想之精华，以为日后之借鉴。</strong></p><p>对于没有指针的语言来说，就不能像单链表一样通过指针域来进行链接。但是大佬就是大佬，他们提出使用数组来代替指针。</p><p>让数组的每个元素都是由两个数据域组成，<code>data</code>和<code>cur</code>。数组的每个下标都对应一个<code>data</code>和一个<code>cur</code>。<code>cur</code>叫做游标，相当于单链表中的next指针，存放后继元素中的数组下标。</p><p>通常对数组中第一个和最后一个元素，不存数据。</p><img src="/b6f9ab9c/3.12.jpg" style="zoom:50%;"><p>数组的第一个元素的<code>cur</code>存放备用链表的第一个结点的下标；最后一个元素的<code>cur</code>存放第一个有数值的元素的下标，相当于单链表中的头结点。</p><p>初始化的空的静态链表代码如下：</p><img src="/b6f9ab9c/image-20200410141849219.png" alt="image-20200410141849219" style="zoom:50%;"><h4 id="静态链表的插入"><a href="#静态链表的插入" class="headerlink" title="静态链表的插入"></a>静态链表的插入</h4><p>为了找到数组中哪些分量未被使用，通过将所有未被使用过的以及删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入得新节点。</p><p>返回待插入结点得下标代码：</p><img src="/b6f9ab9c/image-20200410142806293.png" alt="image-20200410142806293" style="zoom:50%;"><p>插入第i个元素的代码如下：</p><img src="/b6f9ab9c/image-20200410143030586.png" alt="image-20200410143030586" style="zoom:50%;"><img src="/b6f9ab9c/image-20200410143502306.png" alt="image-20200410143502306" style="zoom:50%;"><h4 id="静态链表的删除"><a href="#静态链表的删除" class="headerlink" title="静态链表的删除"></a>静态链表的删除</h4><img src="/b6f9ab9c/image-20200410155117543.png" alt="image-20200410155117543" style="zoom:50%;"><p>释放结点的实现代码：</p><img src="/b6f9ab9c/image-20200410162351065.png" alt="image-20200410162351065" style="zoom:50%;"><p>其中<code>Free_SSL(L, j)</code>为：</p><img src="/b6f9ab9c/image-20200410161553053.png" alt="image-20200410161553053" style="zoom:50%;"><img src="/b6f9ab9c/image-20200410155117543.png" alt="image-20200410155117543" style="zoom:50%;"><h4 id="静态链表的长度"><a href="#静态链表的长度" class="headerlink" title="静态链表的长度"></a>静态链表的长度</h4><p>实现代码：</p><img src="/b6f9ab9c/image-20200410162848974.png" alt="image-20200410162848974" style="zoom:50%;"><p>根据下面这个图就明白了：</p><img src="/b6f9ab9c/image-20200410163203790.png" alt="image-20200410163203790" style="zoom:50%;"><p><code>i</code>的初始值为<code>1</code>，然后一直循环，知道最后一个元素的cur值为0，即<code>i=0</code>后跳出循环，通过计数<code>j</code>得出元素的个数。</p><h4 id="静态链表的优缺点"><a href="#静态链表的优缺点" class="headerlink" title="静态链表的优缺点"></a>静态链表的优缺点</h4><img src="/b6f9ab9c/image-20200410163553225.png" alt="image-20200410163553225" style="zoom:50%;"><p>总上可知，静态链表主要是针对没有指针的语言。对于有指针的语言，不会用到它的。主要是学习其思想。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。</p><img src="/b6f9ab9c/image-20200410164234277.png" alt="image-20200410164234277" style="zoom:50%;"><p>循环链表和单链表的主要<strong>差异在循环的判断条件</strong>上：</p><ul><li>单链表是判断<code>p-&gt;next</code>是否为空，来判断是否停止；</li><li>循环链表是判断<code>p-&gt;next</code>是否等于头结点，来判断是否循环结束；</li></ul><p>将两个循环链表合并：</p><img src="/b6f9ab9c/image-20200410164737635.png" alt="image-20200410164737635" style="zoom:50%;"><p><img src="/b6f9ab9c/image-20200410164807110.png" alt="image-20200410164807110"></p><p>只需要执行以下代码即可实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = rearA-&gt;next;            <span class="comment">//保留A的头，即①</span></span><br><span class="line">rearA-&gt;next = rearB-&gt;next-&gt;next; <span class="comment">// 即A的尾指针指向B的第一个结点,即②</span></span><br><span class="line">rearB-&gt;next = p; <span class="comment">// B的尾指针指向A头结点，形成循环链表，即③</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// p是新建的一个指针，用完后要及时释放，否则可能会内存泄漏和占用            //内存</span></span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>为了克服链表单向性这一缺点，<strong>在单链表的每个结点中，再设置一个指向其前驱结点的指针域，形成双向链表</strong>。</p><p>双向循环链表：</p><img src="/b6f9ab9c/image-20200410170503719.png" alt="image-20200410170503719" style="zoom:50%;"><p><code>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next</code>这应该很好理解吧！</p><p>双向链表很多都是由单向链表扩展的，基本操作大同小异。但是在插入操作时要<strong>注意顺序</strong>，千万不能反了。</p><img src="/b6f9ab9c/image-20200410170906257.png" alt="image-20200410170906257" style="zoom:50%;"><img src="/b6f9ab9c/image-20200410170935055.png" alt="image-20200410170935055" style="zoom:50%;"><p>由于第2步和第3步，都用到了<code>p-&gt;next</code>如果先执行第四步，则使<code>p-&gt;next</code>提前变为<code>s</code>。<strong>顺序使先搞定<code>s</code>的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继</strong>。</p><p>删除操作：</p><img src="/b6f9ab9c/image-20200410171325723.png" alt="image-20200410171325723" style="zoom:50%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><hr><p>感谢阅读:smile:.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬取淘宝商品名称和价格</title>
      <link href="/a4e5e07c.html"/>
      <url>/a4e5e07c.html</url>
      
        <content type="html"><![CDATA[<hr><p>在B站上观看北京理工大学的爬虫慕课，在爬取淘宝商品价格和名称时出现了只出表头信息的结果。</p><a id="more"></a><p><img src="/a4e5e07c/p1.png" alt></p><p>经过在视频下方评论区的方法发现依然有错，最后发现是自己的拼写错误:joy:</p><p>发话不多说直接上教程：（<strong>我使用的是chrome浏览器</strong>）</p><p>在淘宝页面右键，点击检查：</p><img src="/a4e5e07c/p2.jpg" style="zoom:50%;"><p>然后在源代码区进行以下步骤：</p><ul><li><p>1、点击<code>Network</code></p></li><li><p>2、刷新页面，点击<code>Name</code>中的第一个<code>search?</code></p></li><li><p>3、在<code>Headers</code>中复制<code>cookie和user-agent</code>内容</p><p> <img src="/a4e5e07c/p3.jpg" alt></p></li></ul><p><strong>把复制的内容放到如下位置：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTML</span><span class="params">(url)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'解析开始'</span>)</span><br><span class="line">        headers = &#123;</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span>,</span><br><span class="line">        <span class="string">'cookie'</span>: <span class="string">'miid=1204848422178730713; thw=cn; cna=/FjUFFH98VYCAbfHca7IzgoX; tracknick=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; tg=0; hng=CN%7Czh-CN%7CCNY%7C156; enc=S9dNZWnBqTugKoqk7f9MpczA8QNKFdbWP8Dab4FEeTI43rFE%2B%2FrwSE7PnLJF%2BRA5yy70RD7m9rnCJyj72bByLg%3D%3D; t=23bd277878acd720dad699e1cc1f655d; cookie2=1266fc62e2cc3c4136c7085328db7985; v=0; _tb_token_=3fe6ee4e766b8; alitrackid=www.taobao.com; lastalitrackid=www.taobao.com; _samesite_flag_=true; sgcookie=EvIOOHQLzH3Oo804wQlio; unb=2278212962; uc3=lg2=VFC%2FuZ9ayeYq2g%3D%3D&amp;nk2=0ryj1fYS8gv0fQ%3D%3D&amp;vt3=F8dBxdAUzLP9Oq23c0M%3D&amp;id2=UUpmlOw4s1nHfg%3D%3D; csg=f123a494; lgc=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; cookie17=UUpmlOw4s1nHfg%3D%3D; dnk=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; skt=a5e20976396f587e; existShop=MTU4NjA4MzcyMA%3D%3D; uc4=id4=0%40U2gsGA%2BPaSbBR0Lnefhgm24jPZLA&amp;nk4=0%400A28Ox7kSTkcIvypO6o%2FqsLX5wQe; _cc_=VT5L2FSpdA%3D%3D; _l_g_=Ug%3D%3D; sg=%E9%A3%9E2f; _nk_=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; cookie1=VAn7B4bWBvYsc6mrUjgaw%2F%2F8dWi4qfHRI6oPI3CZaYI%3D; tfstk=c47CBgD9vvDCt6DJ59NwYM0dAv8RZXe6sk9dOGUC18n-cLCCix02nXEhqA09DC1..; mt=ci=3_1; JSESSIONID=E9C7BE989C9A4781DC9BDF55EE086724; l=dBLuPSIcqWzW1J7tBOCgqDBHHA7TYIRAgulLJpFvi_5Iw6Y1A2QOo1N4MFv6cjWft28B4z6vzNe9-etlsn4pJA--g3fydxDc.; isg=BNDQjY51utpNoGWOeaq5eOihoR4imbTj3pjtcMqhxyv-BXCvcqgLcyd_3c3l1Wy7; uc1=cookie16=U%2BGCWk%2F74Mx5tgzv3dWpnhjPaQ%3D%3D&amp;cookie21=W5iHLLyFeYZ1WM9hVnmS&amp;cookie15=URm48syIIVrSKA%3D%3D&amp;existShop=false&amp;pas=0&amp;cookie14=UoTUPOT6s4ShJw%3D%3D&amp;tag=8&amp;lng=zh_CN'</span>,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">        h = requests.get(url, headers = headers)</span><br><span class="line">        h.raise_for_status()</span><br><span class="line">        h.encoding = h.apparent_encoding</span><br><span class="line">        <span class="comment">#print(h.text)</span></span><br><span class="line">        <span class="keyword">return</span> h.text</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'html解析失败'</span></span><br></pre></td></tr></table></figure><p>修改划线位置，把自己的user-agent和cookie粘贴即可。</p><p><img src="/a4e5e07c/p4.jpg" alt></p><p>至此，若代码没有拼写等低级错误就会成功输出正确信息。</p><p><img src="/a4e5e07c/p5.jpg" alt></p><p>我自己就是因为<u><strong>拼写错误</strong></u>只输出了表头。</p><p><img src="/a4e5e07c/p6.jpg" alt></p><hr><p>另外一个检查错误的技巧就是巧用print（）函数，来检查代码执行到哪里出错，以及是否输出正确信息。我就是通过这个方法一步步查找到<code>plt</code>得到的返回值为零，然后发现<code>price</code>拼写错误了。</p><hr><p>谢谢阅读:happy:</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各板块透明度设置（无坑版）</title>
      <link href="/undefined.html"/>
      <url>/undefined.html</url>
      
        <content type="html"><![CDATA[<p>在网上找了各种修改透明度的教程，一路踩坑终于调整成功！特此总结防止入坑。</p><a id="more"></a><p>效果预览：<a href="https://zeroflycui.github.io" target="_blank" rel="noopener">https://zeroflycui.github.io</a></p><h1 id="文章主题以及评论区透明度设置"><a href="#文章主题以及评论区透明度设置" class="headerlink" title="文章主题以及评论区透明度设置"></a>文章主题以及评论区透明度设置</h1><p>首先找到此路径  \blog\themes\next\source\css_schemes\Gemini 下的index.styl 文件。</p><img src="/undefined/路径1.jpg" style="zoom:50%;"><p>打开index.styl文件，把 .post-block 下的background后的改为rgba(255,255,255,0.6), 最后的数值是透明度设置，自己调整。</p><img src="/undefined/设置1.jpg" style="zoom:50%;"><p>效果：</p><img src="/undefined/背景透明度2.jpg" style="zoom:50%;"><h1 id="侧边栏透明度设置"><a href="#侧边栏透明度设置" class="headerlink" title="侧边栏透明度设置"></a>侧边栏透明度设置</h1><p>打开以下路径 \blog\themes\next\source\css_schemes\Pisces 下的_sidebar.styl,修改 .sidebar以及.sidebar-inner 下的background：rgba(255,255,255,0.6).如下图所示：</p><img src="/undefined/设置2.jpg" style="zoom:50%;"><p>效果图：</p><img src="/undefined/设置3.jpg" style="zoom:50%;"><hr><p>修改完成，如果有错请通知。谢谢阅读！！</p><p>参考博文链接：</p><p><a href="http://www.aomanhao.top/2019/01/20/theme_NextConfig1/" target="_blank" rel="noopener">http://www.aomanhao.top/2019/01/20/theme_NextConfig1/</a></p><p><a href="https://blog.csdn.net/qq_43414603/article/details/104113198" target="_blank" rel="noopener">https://blog.csdn.net/qq_43414603/article/details/104113198</a></p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
            <tag> 透明度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
