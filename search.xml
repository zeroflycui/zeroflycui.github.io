<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数组中重复的数字</title>
      <link href="/8f265477.html"/>
      <url>/8f265477.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>在数组中找重复数字的方法：一般有全遍历，依次比较数组中是否有重复的数字，但是时间复杂度较大；还有一种是通过HashMap进行判断重复，但空间复杂度又会增加。</p><p>此题可以使用一种新的判断重复的方法：</p><ul><li>将给定的数组中元素<code>a[i]</code>，与对应的下标<code>i</code>相比较；<ul><li>若相等则遍历下一个元素<code>i+1</code>；</li><li>若不相等，则将以此元素<code>a[i]</code>为下标的元素<code>a[a[i]]</code>进行比较；<ul><li>若相等，则说明有重复数字<code>a[i]</code>；</li><li>若不想等，则将两个元素互换位置；并执行以上所有步骤，直到遍历完数组。</li></ul></li></ul></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span> || numbers == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断数组中元素是否在 0~n-1 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[j] &lt; <span class="number">0</span> || numbers[j] &gt; length - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若 i != a[i]</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[i] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若 a[i] != a[a[i]] 交换两个元素的位置</span></span><br><span class="line">                <span class="keyword">if</span> (numbers[i] != numbers[numbers[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">                    numbers[i] = numbers[numbers[i]];</span><br><span class="line">                    numbers[temp] = temp;</span><br><span class="line">                    <span class="comment">// 这步交换可以直接使用 swap()函数；</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    *duplication = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_50.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_50.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 重复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把字符串转换为整数</title>
      <link href="/5b88b5e3.html"/>
      <url>/5b88b5e3.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><p>输入描述：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串,包括数字字母符号,可以为空</span><br></pre></td></tr></table></figure></blockquote><p>输出描述</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是合法的数值表达则返回该数字，否则返回0</span><br></pre></td></tr></table></figure></blockquote><p>示例1：</p><p>输入：</p><blockquote><p>+2147483647<br>1a33</p></blockquote><p>输出：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2147483647</span><br><span class="line">0</span><br></pre></td></tr></table></figure></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题意要求给的字符串必须满足以下要求：</p><ul><li><p>字符串不为空；</p></li><li><p>字符串中的元素必须是<code>0~9</code>的数字，或者表示正负的 <code>+\-</code>;</p></li><li><p>int 为32位，需要判断是否发生溢出；</p></li><li><p>判断是否正常结束；</p></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Status &#123;kValia = <span class="number">0</span>, kInValia&#125;; <span class="comment">// 枚举</span></span><br><span class="line">    <span class="keyword">int</span> g_nStatus = kValia;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str(); <span class="comment">// 指向字符串str的地址</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cstr != <span class="literal">NULL</span> &amp;&amp; *cstr != <span class="string">'\0'</span>) <span class="comment">// 字符串不是空，</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> minus = <span class="literal">false</span>; <span class="comment">// 正负号的标志，默认正为false</span></span><br><span class="line">            <span class="keyword">if</span> (*cstr == <span class="string">'+'</span>)</span><br><span class="line">                cstr++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*cstr == <span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                minus = <span class="literal">true</span>;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (*cstr != <span class="string">'\0'</span>)</span><br><span class="line">                num = StrToIntCore(cstr, minus);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cstr, <span class="keyword">bool</span> minus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (*cstr != <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*cstr &gt;= <span class="string">'0'</span> &amp;&amp; *cstr &lt;= <span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> flag = minus ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                num = num * <span class="number">10</span> + flag * (*cstr - <span class="string">'0'</span>); <span class="comment">// 一个数字字符减去零字符，得到的是整型数</span></span><br><span class="line">                <span class="keyword">if</span> ((!minus &amp;&amp; num &gt; <span class="number">0x7fffffff</span>) || (minus &amp;&amp; num &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>)) <span class="comment">// 有符号int 的取值范围-2147483648~2147483647</span></span><br><span class="line">                &#123;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否正常结束</span></span><br><span class="line">        <span class="keyword">if</span> (*cstr == <span class="string">'\0'</span>)</span><br><span class="line">            g_nStatus = kValia;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，在牛客上不能通过，测试用例为：-2147483649超出 int 的取值范围。</p><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_49.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_49.html</a></p><p><a href="https://www.nowcoder.com/questionTerminal/1277c681251b4372bdef344468e4f26e?f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/1277c681251b4372bdef344468e4f26e?f=discussion</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不适用四则运算符计算两个数的和</title>
      <link href="/801cb1c0.html"/>
      <url>/801cb1c0.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>写一个函数，求两个整数之和，要求在函数体内不得使用+，-，*，/四则运算符。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先两个整数正常相加的过程主要是通过三步： 例如 5 + 7 = 12</p><ul><li>将各位相加，不进位；为 <code>2</code></li><li>计算进位值，<code>10</code>;</li><li>然后，变为10 + 2，继续循环以上两步，直到没有进位（进位值为0）； ==》12</li></ul><p>对应二进制计算： 5——101， 7——111</p><ul><li>将各位相加，不进位；得到<code>010</code>，可发现二进制相加类似于<strong>异或操作</strong> <code>101 ^ 111 = 010</code></li><li>计算进位值，<code>1010</code>，可发现二进制进位类似于<strong>与操作之后向左平移1</strong> ，<code>101 &amp; 111 = 101 &lt;&lt; 1 = 1010</code></li><li>然后，变为010 + 1010，继续循环以上两步，直到没有进位（进位值为0）；</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add_Solution</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp1 = num1;</span><br><span class="line">        <span class="keyword">int</span> temp2 = num2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (temp2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> num1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (temp2 != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp1 = num1 ^ num2;</span><br><span class="line">            temp2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>; <span class="comment">// 注意 按位与&amp;的优先级要低于 平移操作符 &lt;&lt;</span></span><br><span class="line">            num1 = temp1;</span><br><span class="line">            num2 = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num2 ? (Add(num1 ^ num2, (num1 &amp; num2) &lt;&lt; <span class="number">1</span>)) : num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_48.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_48.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 进制转化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求1+2+3+...+n</title>
      <link href="/e799159.html"/>
      <url>/e799159.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>其中两种思路：</p><ul><li>直接使用求和公式 <code>s = (1 + n) * n / 2</code></li><li>使用递归的方法</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公式方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        sum = (<span class="number">1</span> + n) * n /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        sum &amp;&amp; (sum += Sum_Solution(--n)); <span class="comment">// 当n减到 0时即为递归停止的条件，注意是 --n,不是n--</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_47.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_47.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孩子们的游戏（圆圈中最后剩下的数）</title>
      <link href="/1751c933.html"/>
      <url>/1751c933.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 。如果没有小朋友，请返回 -1.</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>把原题简化后：有n个人（0 ~ n-1），遇到 m 报数并出列，然后以下一个人为 0 开始继续报数，报m 出列，如此以往，直到只剩下一人，并返回他的编号。若无人剩下，则返回 -1.</p><p>这和著名的约瑟夫环问题一样：</p><blockquote><p>约瑟夫游戏的大意：30个游客同乘一条船，因为严重超载， 加上风浪大作，危险万分。因此船长告诉乘客，只有将全船 一半的旅客投入海中，其余人才能幸免于难。无奈，大家只 得同意这种办法，并议定30 个人围成一圈，由第一个人数起，依次报数，数到第9人，便把他投入大海中，然后再从 他的下一个人数起，数到第9人，再将他投入大海中，如此 循环地进行，直到剩下 15 个游客为止。问：哪些位置是将 被扔下大海的位置？ </p></blockquote><p>例如：有9个数字  ，从开始到第三个人时出列。</p><p><img src="/1751c933/image-20200602174837856.png" alt="image-20200602174837856"></p><p>可以知道，当n 对应着9，8，7，6，5，4，3，2，1时，则最终存活的 1 对应的原始位置是：0，6，3，0，3，0，1，1，0</p><p>m = 3,   <code>f(9) = 0</code>，<code>f(8) = 6</code>    <code>f(9) = (f(8)  + m) % 9 = 0</code>, 同样有<code>f(8) = (f(7)  + m) % 8 = 6</code>等等。</p><p>通过数学归纳法可以得到：<code>f(1) = 0;   f(n) = (f(n-1) + m) % n      n &gt; 1;</code></p><p>可以通过这个公式解决题目给的问题。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            last = (last + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再有一种就是通过双向链表，进行模拟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    ListNode (<span class="keyword">int</span> x): val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建一个双向链表</span></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* pre = head;</span><br><span class="line">    ListNode* temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 将 1~n-1插入到链表中</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">        pre-&gt;next = temp;</span><br><span class="line">        pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = head; <span class="comment">// 构成双向链表</span></span><br><span class="line">    </span><br><span class="line">    ListNode* temp2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m <span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp2 = temp2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp2-&gt;next = temp2-&gt;next-&gt;next;</span><br><span class="line">        head = temp2-&gt;next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码：我在VS19上运行没问题，但是在牛客上出现 <code>ListNode</code>重载。不知道为啥？</p><p>欢迎各位讨论。</p><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_46.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_46.html</a></p><p><a href="https://blog.nowcoder.net/n/81a858b422804183a1a51dbfd4084ebc" target="_blank" rel="noopener">https://blog.nowcoder.net/n/81a858b422804183a1a51dbfd4084ebc</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 约瑟夫环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扑克牌顺子</title>
      <link href="/c2f2d418.html"/>
      <url>/c2f2d418.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>说了一大堆，根据所给代码不难判断出，目的就是为了判断所给的容器中的元素，是否为5个连续的数字，但是这5个数字有要求：</p><ul><li>只有5个数字；</li><li>数字是连续的；</li><li>数字是在0~13之间；</li><li>没有重复的数字；</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">14</span>, <span class="built_in">max</span> = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curNum = numbers[i];</span><br><span class="line">            <span class="keyword">if</span> (curNum &lt; <span class="number">0</span> || curNum &gt; <span class="number">13</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (curNum == <span class="number">0</span>) <span class="comment">// 大小王可以为任意值，直接跳过此循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 判断是否有重复数字</span></span><br><span class="line">            <span class="keyword">if</span> ((flag &gt;&gt; curNum) &amp; <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 更新记录数字出现的次数（可以理解为，大小为curNum的数字出现的标记）</span></span><br><span class="line">            flag |= <span class="number">1</span> &lt;&lt; curNum;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新最小值</span></span><br><span class="line">            <span class="keyword">if</span> (curNum &lt; <span class="built_in">min</span>)</span><br><span class="line">                <span class="built_in">min</span> = curNum;</span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            <span class="keyword">if</span> (curNum &gt; <span class="built_in">max</span>)</span><br><span class="line">                <span class="built_in">max</span> = curNum;</span><br><span class="line">            <span class="comment">// 判断是否有 5 个元素</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">max</span> - <span class="built_in">min</span> &gt;= <span class="number">5</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以<code>{4,4,5,6,7}</code>和 <code>{4,5,6,7,8}</code>为例：</p><p><img src="/c2f2d418/image-20200601183449147.png" alt="image-20200601183449147"></p><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_45.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_45.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转单词顺序</title>
      <link href="/3ad2c455.html"/>
      <url>/3ad2c455.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一开始，我认为给定的句子，是杂乱的没有什么规律的排序。后来才知道，给的字符串中句子，就是单词前后翻转的。是我想复杂了😂</p><p>仔细观察就会发现，先将每个单词翻转，然后就是将整个字符串翻转就能得到正确结果。</p><p>其中关键，就是怎样将每个单词翻转。<strong>当然是根据每个单词直间的空格 来做区分啦</strong>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result = str;</span><br><span class="line">        <span class="keyword">int</span> length = result.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        result += <span class="string">' '</span>; <span class="comment">// 因为最后一个单词没有空格，故认为添加</span></span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">0</span>; <span class="comment">// 设置一个下一个单词的起始位置</span></span><br><span class="line">        <span class="comment">// 遍历整个字符串，对每个单词翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length + <span class="number">1</span>; i++) <span class="comment">// 这里字符串的长度由于添加了一个空格字符，长度增加一</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result[i] == <span class="string">' '</span>) <span class="comment">// 注意这是 ' '(表示字符)，而不是 " "(表示字符串)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Reverse(result, mark, i - <span class="number">1</span>);</span><br><span class="line">                mark = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = result.substr(<span class="number">0</span>,length); <span class="comment">// 通过复制操作，通过控制复制字符的长度和起始位置，去点添加的空格字符</span></span><br><span class="line">        <span class="comment">// 翻转形成的新字符串</span></span><br><span class="line">        Reverse(result, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">            swap(str[<span class="built_in">begin</span>++], str[<span class="built_in">end</span>--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_44.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_44.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 字符翻转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左旋转字符串</title>
      <link href="/eb78a2fc.html"/>
      <url>/eb78a2fc.html</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>通过给的例子，我第一个想法是，使用queue容器，但发现给的程序返回类型为 <code>string</code>,所以应该是直接对给定的字符串进行操作。</p><p>怎样把字符串前面的字符和后面的字符交换位置呢？想到了<code>swap()</code>交换函数。</p><ul><li>先将前 <code>n-1</code>字符翻转；</li><li>再将剩余的字符翻转；</li><li>将翻转后的字符组成新的字符串，然后将新字符串翻转，即可得到结果；</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> || n &lt; <span class="number">0</span> || n &gt; length)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> result = str;</span><br><span class="line">        <span class="comment">// 翻转前 n 个字符</span></span><br><span class="line">        Reverse(result, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 翻转剩余字符</span></span><br><span class="line">        Reverse(result, n, length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 翻转新的字符串</span></span><br><span class="line">        Reverse(result, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">            swap(str[<span class="built_in">begin</span>++], str[<span class="built_in">end</span>--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://cuijiahua.com/blog/2018/01/basis_43.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_43.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 字符串翻转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和为S的两个数字</title>
      <link href="/18a4cd01.html"/>
      <url>/18a4cd01.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得它们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>输出描述：</p><blockquote><p>对应每个测试案例，输出两个数，小的先输出。</p></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>解题思路和上一次，求递增数组连续数字的和为S的思路一样。</p><ul><li>通过两个指针来实现。一个指针pleft，指向最左元素；另一个指针pright，指向最右边元素；</li><li>计算两个指针指向元素的和，判断当前和与指定和S的大小；</li><li>若当前和 &lt; S，则将左指针向左移动一位；</li><li>若当前和 == S，则将两指针指向的元素压入输出容器中；</li><li>若当前和 &gt; S，则将右指针向右移动一位；</li></ul><p>双指针左右遍历递增序列时，最开始满足和为S的即为乘积最小的两个数。</p><p>证明:</p><blockquote><p>假设 <code>a &lt; b</code>，且存在；</p><p><code>a + b = s</code>内层的两个数</p><p><code>(a - n) + (b + m) = s</code> 外层的两个数</p><p><code>(a - n) + (b + m) = a + b</code> ==&gt; m = n;</p><p><code>(a - n)(b + m) = ab  + am -bn - nm = ab - (b - a)m - m^2 &lt; ab</code></p><p>即可证明。</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pleft = <span class="number">0</span>, pright = <span class="built_in">array</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (pleft &lt; pright)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cursum = <span class="built_in">array</span>[pleft] + <span class="built_in">array</span>[pright];</span><br><span class="line">            <span class="keyword">if</span> (cursum &lt; sum)</span><br><span class="line">                pleft++;</span><br><span class="line">            <span class="keyword">if</span> (cursum == sum)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[pleft]);</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[pright]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursum &gt; sum)</span><br><span class="line">                pright--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和为S的连续正数序列</title>
      <link href="/32db4829.html"/>
      <url>/32db4829.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p>输出描述：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br></pre></td></tr></table></figure></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>通过两个指针，分别指向最低位和最高位。</li><li>通过 <code>(a + b) * n / 2</code>求和公式的到两指针间的和；</li><li>若当前和 小于 指定和S，则最高位指针向左移动一位；</li><li>若当前和 大于 指定和S， 则最低位指针向左移动一位；</li><li>若当前和 等于 指定和S， 则最高位和最低位之间的数组即为所求的连续序列之一；</li><li>如上循环，求出所有序列。知道最低位指针 大于 最高位指针，循环结束。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">FindContinuousSequence</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义最高位和最低为的指向值，由于题中说是正整数序列，且要求至少包括两个连续的数，故有如下定义</span></span><br><span class="line">        <span class="keyword">int</span> phigh = <span class="number">2</span>, plow = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环</span></span><br><span class="line">        <span class="keyword">while</span> (plow &lt; phigh)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> currsum = (plow + phigh) * (phigh - plow + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// 别忘了 +1，</span></span><br><span class="line">            <span class="keyword">if</span> (currsum &lt; sum)</span><br><span class="line">                phigh++;</span><br><span class="line">            <span class="keyword">if</span> (currsum == sum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = plow; i &lt;= phigh; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.push_back(temp);</span><br><span class="line">                plow++; <span class="comment">// 继续对剩下的序列进行查找</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currsum &gt; sum)</span><br><span class="line">                plow++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_41.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_41.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找数组中只出现一次的数字</title>
      <link href="/cb6b882d.html"/>
      <url>/cb6b882d.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写出这两个只出现一次的数字。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>查找数组中只出现一次的树字，一般有以下几种方法</p><ul><li><p>通过两次完全遍历找到，只出现一次的数字。时间复杂度为 O(n^2).</p></li><li><p>通过Hash表 <code>map&lt;int,int&gt;</code> 在遍历的过程中，统计树字出现的次数。时间复杂度为 O(n), 但是空间复杂度不是 O(1).</p></li><li><p>通过异或的方法来判断。由于题中提到，其它的数字都出现两次，只有两个数字只出现一次，根据异或的定义：<strong>当两个数字相同时，返回 0 ，不同返回 1</strong>。 当数组中出现两次的数字异或完后，会变为 0.只剩下只出现一次的 数字。</p><ul><li><p>只有一个只出现一次的数字时，例如： {2,3,2}</p><blockquote><p>2的二进制为 0010， 3的二进制为 0011，0010 ^ 0011 =  0001, 然后将 0001 与 0010 异或 ：0001 ^ 0010 = 0011, 得到的结果是 3的二进制。也就说明，这个数组中，3是出现一次的数字。</p></blockquote></li><li><p>有两个只出现一次的数字时，例如: {2,4,3,6,3,2,5,5} 其中 4， 6只出现一次。但是就不能简单的异或处理了。所以要使用以下解决办法：</p><blockquote><ul><li>首先，将数组的所有元素异或操作完后，判断得到结果二进制表示中第一个 <code>1</code>的位置 <code>n</code>；</li><li>然后根据第 <code>n</code>位为 <code>1</code>的标准将数组分为两个子数组；</li><li>对子数组进行异或操作，得到只出现一次的数字；</li></ul></blockquote></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> OrIndex = <span class="number">0</span>; <span class="comment">// 数组异或操作的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            OrIndex ^= data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> firstBit = FirstBitOf1(OrIndex); <span class="comment">// OrIndex二进制表示中 1 第一次出现的位置</span></span><br><span class="line">        </span><br><span class="line">        *num1 = *num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过第n位是否为 1 将原数组分为两个子数组，并进行异或操作</span></span><br><span class="line">            <span class="keyword">if</span> (IsbitOf1(data[j], firstBit)) </span><br><span class="line">            &#123;</span><br><span class="line">                *num1 ^= data[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                *num2 ^= data[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到原数组异或操作后二进制中第一个 1 的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstBitOf1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 在一个字节中寻找</span></span><br><span class="line">        <span class="keyword">while</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (index &lt; <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断一个二进制数字是否第 n 位为 1 </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsbitOf1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num = num &gt;&gt; index;</span><br><span class="line">        <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_40.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_40.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树</title>
      <link href="/4263f441.html"/>
      <url>/4263f441.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一颗二叉树，判断该二叉树是否是平衡二叉树。 注意：<strong>在这里，只考虑其平衡性，不需要考虑其是不是排序二叉树，即不用考虑，左结点 &lt;  根结点  &lt;   右结点。</strong></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>平衡二叉树，即左右子树的深度相差不超过 <code>1</code>，并且其左右子树也必须是平衡二叉树。</p><p>有两种方法来解决这个问题：</p><ul><li>第一种，从根结点开始，遍历每个结点的同时通过二叉树深度来判断其左右子树是否满足平衡二叉树的条件，这样依次遍历的坏处就是，从上到下的过程中存在大量的重复操作。</li><li>第二种，和后序遍历一样，从下到上开始，先遍历左右结点再遍历根结点，这样在遍历的过程中通过记录深度就判断了左右子树是否为平衡二叉树，减少了很多重复的遍历操作。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>第一种，全遍历的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = GetDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = GetDepth(pRoot-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetDepth</span> <span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = GetDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = GerDepth(pRoot-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (left &gt; right) ? (left + <span class="number">1</span>) : (right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二种方法，只遍历一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced(pRoot, &amp;depth);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> *depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="keyword">if</span> (IsBalanced(pRoot-&gt;left, &amp;left) &amp;&amp; IsBalanced(pRoot-&gt;right, &amp;right))<span class="comment">// 左右树平衡</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dif = left - right;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(dif) &lt; <span class="number">2</span>) <span class="comment">// 左右深度差不大于 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                *depth = <span class="number">1</span> + (left &gt; right ? left : right);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_39.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_39.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的深度</title>
      <link href="/fc8ea05.html"/>
      <url>/fc8ea05.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一颗二叉树，求该树的深度。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>求二叉树深度，通常有两种做法。</p><ul><li>一种是通过深度优先遍历得到二叉树的深度；</li><li>另一种是通过广度优先遍历（层次遍历）得到二叉树的深度；</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">    TreeNode (<span class="keyword">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(pRoot-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (left &gt; right) ? (left + <span class="number">1</span>) : (right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">    TreeNode (<span class="keyword">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; Q;</span><br><span class="line">        </span><br><span class="line">        Q.push(pRoot);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = Q.<span class="built_in">size</span>();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) <span class="comment">// 把每层的结点依次删除，然后存入下一层所有结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left)</span><br><span class="line">                    Q.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right)</span><br><span class="line">                    Q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_38.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_38.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先遍历 </tag>
            
            <tag> 广度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字在排序数组中出现的次数</title>
      <link href="/633aec21.html"/>
      <url>/633aec21.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>统计一个数字在排序数组中出现的次数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>注意这个数组是<strong>有序的</strong>，对于有序数组的查找一半选用二分查找法。</p><p>例如，要查找的数字为 k  ，取数组中间位置的元素 mid ，若 k &lt; mid, 说明要查的 k 在数组的前半段，继续在前半段进行二分查找；若 k==mid 则查找成功；否则在数组后半段采用二分查找。</p><p>本题需要查找数字在数组中出现的次数，只需找到这个数字的第一个位置，和最后一个位置，通过下标即可求得次数。</p><p>时间复杂度为 O(logn)。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> first = FirstPost(data, k, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = EndPost(data, k, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (first != <span class="number">-1</span> &amp;&amp; <span class="built_in">end</span> != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">end</span> - first + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 采用递归得方法得到 第一次出现得下标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstPost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data, <span class="keyword">int</span> k, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> &gt; <span class="built_in">end</span>) <span class="comment">// 递归退出的条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">end</span> + <span class="built_in">begin</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midData = data[mid];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (midData == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid &gt; <span class="number">0</span> &amp;&amp; data[mid - <span class="number">1</span>] != k) || mid == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midData &gt; k)</span><br><span class="line">            <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">begin</span> = mid + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> FirstPost(data, k, <span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采用循环得方法得到最后一次出现得下标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">EndPost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data, <span class="keyword">int</span> k, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">begin</span> + <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midData = data[mid];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">begin</span> &lt;= <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (midData == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mid &lt; data.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; data[mid + <span class="number">1</span>] != k) || mid == data.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">begin</span> = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (midData &gt; k)</span><br><span class="line">                <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">begin</span> = mid + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            mid = (<span class="built_in">begin</span> + <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">            midData = data[mid];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 获得第一次的位置可以使用循环的方法得到，同样最后一次的位置也可用递归的方法得到。</p><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_37.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_37.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个链表的第一个公共结点</title>
      <link href="/ce7da11c.html"/>
      <url>/ce7da11c.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>第一个公共结点，即从某个结点开始，两个链表指针指向的地址都是相同的。</p><p><img src="https://cuijiahua.com/wp-content/uploads/2018/01/basis_36_1.png" alt="img"></p><p>解决这个问题有两个方法：</p><p>方法一：</p><p>​    可以把两个链表拼接起来，链表A在前链表B在后，另一种拼接方法是链表B在前链表A在后。然后同时遍历两个这两个链表，就能找到公共结点。时间复杂度为O(m+n), 空间复杂度O(m+n).</p><p><img src="/ce7da11c/image-20200530090729626.png" alt="image-20200530090729626"></p><p>方法二：</p><p>可以先把长的链表的头砍掉，让两个链表的长度相同，然后再同时遍历，也能找到公共结点。时间复杂度为 O(m+n), 空间复杂度为 O(max（m，n)）。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    ListNode (<span class="keyword">int</span> x): bal(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = getLength(pHead1); <span class="comment">// pHead1链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len2 = getLength(pHead2);<span class="comment">// pHead2链表长度</span></span><br><span class="line">        </span><br><span class="line">        ListNode* LongList = pHead1;</span><br><span class="line">        ListNode* ShortList = pHead2;</span><br><span class="line">        <span class="keyword">int</span> OverList = len1 - len2;</span><br><span class="line">        <span class="keyword">if</span> (len1 &lt; len2) <span class="comment">// 假如pHead1的长度小于pHead2的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* LongList = pHead2;</span><br><span class="line">            ListNode* ShortList = pHead1;</span><br><span class="line">            <span class="keyword">int</span> OverList = len2 - len1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 砍掉长链表的多出的部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; OverList; i++)</span><br><span class="line">            LongList = LongList-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (LongList != <span class="literal">NULL</span> &amp;&amp; ShortList != <span class="literal">NULL</span> &amp;&amp; LongList != ShortList)</span><br><span class="line">        &#123;</span><br><span class="line">            LongList = LongList-&gt;next;</span><br><span class="line">            ShortList = ShortList-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LongList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_36.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_36.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个只出现一次的字符</title>
      <link href="/50f3eaff.html"/>
      <url>/50f3eaff.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个字符串（0&lt;=字符串长度&lt;=10000，全部由字母组成）中找到第一个只出现一次的字符，并返回它的位置，如果没有则返回-1（需要区分大小写）。（从0开始计数）</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>通过创建一个HashMap来辅助每个字符的计数。第一遍遍历得到每个字母出现的次数，第二遍遍历，找出次数为 1 的第一个字母，并返回下标。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; item; <span class="comment">// 键表示字母，值表示出现的次数</span></span><br><span class="line">        <span class="comment">// 第一次遍历得到每个字母出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            item[str[i]]++;</span><br><span class="line">        <span class="comment">// 第二次遍历找到第一个出现次数为1的字母下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (item[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_34.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_34.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丑数</title>
      <link href="/73645ce2.html"/>
      <url>/73645ce2.html</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把只含质因子2、3和5的数称为丑数。例如6、8都是丑数。但14不是，因为有因子 7 .习惯上把 1 当做第一个丑数。求按从小到大的顺序的第N个丑数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>根据丑数定义，说明丑数只能被2、3、5整除。同时也说明，若已知前面的丑数，乘2、3或5就可以得到之后的丑数。</p><p>例如存在一个乘 2 得到的丑数 T2，排在它之前的每一个丑数乘 2 后都不会 大于当前最大丑数。同样还存在乘3的T3，乘5的T5。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">7</span>) <span class="comment">// 因为 1，2，3，4，5，6都是丑数</span></span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(index)</span></span>; <span class="comment">// ???</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            res[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">3</span>, t3 = <span class="number">2</span>, t5 = <span class="number">1</span>; <span class="comment">// 在前6个丑数中，满足乘相应因子不大于最大丑数6的最大数组下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">6</span>; i &lt; index; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] =<span class="built_in">min</span>(res[t2] * <span class="number">2</span>,<span class="built_in">min</span>(res[t3] * <span class="number">3</span>, res[t5] * <span class="number">5</span>));</span><br><span class="line">            <span class="keyword">while</span> (res[i] &gt;= res[t2] * <span class="number">2</span>)</span><br><span class="line">                t2++;</span><br><span class="line">            <span class="keyword">while</span> (res[i] &gt;= res[t3] * <span class="number">3</span>)</span><br><span class="line">                t3++;</span><br><span class="line">            <span class="keyword">while</span> (res[i] &gt;= res[t5] * <span class="number">5</span>)</span><br><span class="line">                t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_33.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_33.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 丑数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把数组排成最小的数</title>
      <link href="/ce969fd0.html"/>
      <url>/ce969fd0.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的那个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323.</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>要得到最小的数字，即需要最高位的数字要最小，但这不是简单的判断数组中元素数值的大小，而是需要数组元素从左到右的最高位数字要小，例如：{9，111}组成的最小数为 1119，而不是9111.  可以通过将数字转换为字符串然后比较字符串的大小，即满足从左到右每个最高位上数字小。</p><p>自定义一种排列顺序规则：</p><p>将a 和 b 转换为字符串，若 a + b &lt; b + a   ==&gt;  a &lt; b;   若 a + b &gt; b + a   ==&gt;   a &gt; b;  若 a + b = b + a  ==&gt; a=b.</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> A = to_string(a) + to_string(b);</span><br><span class="line">        <span class="built_in">string</span> B = to_string(b) + to_string(a);</span><br><span class="line">        <span class="keyword">return</span> A &lt; B; <span class="comment">// 意味着，当A&lt;B时，把a放到b前，按小到大排序。当A&gt;B时，返回0，交换位置。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        sort (numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result += to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C++中，cmp函数需要使用 static 进行声明，声明是静态成员函数，这样才能正确调用。</p><p>参考博文链接：<a href="https://cuijiahua.com/blog/2018/01/basis_32.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2018/01/basis_32.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数中1出现的次数</title>
      <link href="/42e11ab6.html"/>
      <url>/42e11ab6.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求出任意非负整数区间中1出现的次数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>可以采用数学之美中提出的方法，对整数进行分割，通过使用1，10，100，等依次乘10的顺序，将整数分为个位，十位，百位，等等。然后对每一位上<code>1</code>出现的次数进行统计。</p><p>以下内容有自己理解的部分，<strong>仅供参考，若有错误请大佬指教</strong></p><ul><li>把给定的整数<code>n</code>进行分割，分为两部分，高位<code>n/i</code>和地位<code>n%i</code>；</li><li>例如对整数n=3145，进行分析：<ul><li>个位为5 &gt; 2，当个位取 1 时，分为<code>a=n/1=3145,  b=n%1=0</code>，个位前面的数字可由 0~314组成，共有<code>a/10+1 = 315</code>；</li><li>十位为4 &gt; 2，当个位取 1 时，分为 <code>a=n/10=314,   b=n%10=5</code>，十位前面的数字可由 0<del>31 组成，十位后面可由 0</del>9 组成（因为十位大于 1，当十位借去1后相当于还剩余30，这足够个位 0~9数字的出现），因此共有<code>a/10 + 1 = 32</code>次包含 10 个连续点，因此十位为 1 的次数为：<code>(a/10 + 1)*10</code>；</li><li>百位为 1 ，当百位取 1 时，分为 <code>a=n/100=31   b=n%100=45</code>，百位前面由 0<del>3组成，后面只能由 0</del>45构成，因此需要向前借 1 ，即前面由 0<del>2组成，后面由 0</del>99组成。此时会有 <code>a/10=3</code>次包含100个连续点，由于百位为1，所以还包含 <code>b+1=46</code>个点，因此百位为 1 的次数共有 <code>a/10*100 + (b+1)=346</code>;</li><li>千位为3 &gt; 2，当取 1 时，分为 <code>a=n/1000=3   b=n%1000=145</code>，千位后面由 0~999组成，因此千位上 1 出现的次数为 <code>a/10 + 1 = 1</code>次包含1000个连续点，因此千位上为 1 的次数为 <code>(a/10 + 1)*1000=1000</code>；</li></ul></li></ul><p>对于当前位为 0 的情况，和取 1 的情况类似，例如 n=502，十位为0，当十位取 1 时，高位<code>a=n/10=50</code>,低位<code>b=n%10=2</code>十位之前由0<del>5组成，而十位之后由 0</del>2组成；因此需要向高位借 1 ，变为，高位由  0<del>4组成，地位由 0</del>9组成。所以在十位上 1 出现的次数为：<code>a/10=5</code>次包含10个连续点，共<code>(a/10)*10=50</code>；</p><p>综上可以总结为，无论当前位置无论是 &gt;=2, 还是 等于 0 或 1，该位置上1出现的次数都可以通过以下公式来计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a + 8)&#x2F;10 * i + (a%10 &#x3D;&#x3D; 1) * (b + 1);  i &#x3D; (1,10,100,1000 ...)</span><br></pre></td></tr></table></figure><p>关于 a+8， 因为当前位置上的数值 &gt; 2 时，该位置上 1 出现的次数为 <code>a/10 + 1</code> 与 小于  2 时的 <code>a/10</code>相差 1，由于两个公式的差异是以 2 为分界线，通过 a+8，来构造进位与不进位的效果，使所有情况使用同一公式。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = n / i, b = n % i;</span><br><span class="line">            count += (a + <span class="number">8</span>) / <span class="number">10</span> * i + (a % <span class="number">10</span> == <span class="number">1</span>)*(b + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_31.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_31.html</a></p><p><a href="https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6?f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6?f=discussion</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小的k个数</title>
      <link href="/47d70a1.html"/>
      <url>/47d70a1.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入n个整数，找出其中最小的k个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是，1,2,3,4</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>最简单的方法是，直接使用<code>sort</code>函数对输入数组进行排序，然后输出前k个元素。其时间复杂度为<code>O(nlogn)</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (input.empty() || k&lt;=<span class="number">0</span> || k &gt; input.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        sort(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有一种时间复杂度<code>O(nlogk)</code>的堆排序方法，要优于上述方法。</p><p>堆排序，分为大顶堆排序和小顶堆排序。<strong>堆排序适合海量数据的处理</strong></p><p>堆是具有下列性质的<strong>完全二叉树</strong>：每个结点的值都<strong>大于或等于</strong>左右孩子的值，称为大顶堆；或者每个结点的值都<strong>小于或等于</strong>其左右孩子结点的值，称为小顶堆。</p><ul><li><p>首先构建一个二叉树型的数据容器，用于存放数组的前<code>k</code>个值。</p><ul><li><p>然后对这<code>k</code>个值进行大顶堆构建，</p></li><li><p>然后将无序的大顶堆排序为有序的大顶堆</p></li><li><p>判断第<code>k</code>个之后的元素与数据容器中最后一个元素（即容器中最大的元素）进行比较</p><ul><li>若小于容器中最后一个元素，则进行交换，交换后重新构建大顶堆；</li><li>否则跳过判断数组中下一个元素</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> parent, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = input[parent];</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">2</span>*parent + <span class="number">1</span>; <span class="comment">// 左树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (child&lt;length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (child+<span class="number">1</span> &lt; length &amp;&amp; input[child] &lt; input[child+<span class="number">1</span>])<span class="comment">// 判断左右树的大小</span></span><br><span class="line">                child++; <span class="comment">// 若条件成立，则说明右树大</span></span><br><span class="line">            <span class="keyword">if</span> (temp&gt;=input[child]) <span class="comment">// 若当前根结点大于等于最大左右子树，则直接跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            input[parent] = input[child]; <span class="comment">// 将较大的子树结点赋值给当前根结点</span></span><br><span class="line">            <span class="comment">// 对下一层进行大顶堆排序</span></span><br><span class="line">            parent = child;</span><br><span class="line">            child = <span class="number">2</span>*parent +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        input[parent] = temp; <span class="comment">// 将原根结点的值赋值给替换的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (input.empty() || k &lt;= <span class="number">0</span> || k &gt; input.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历输入的n个整数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="built_in">size</span>() &lt; k) <span class="comment">// 若result中的元素小于k时直接存放在result容器中</span></span><br><span class="line">                result.push_back(input[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 对result容器中k个元素进行大顶堆排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = k/<span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                    HeadAdjust(result, j, k);  </span><br><span class="line">                <span class="comment">// 将无序的大顶堆进行有序排列,将堆顶与最后一个元素互换，然后对前k-1个元素进行大顶堆排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = k <span class="number">-1</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(result[<span class="number">0</span>],result[j]);</span><br><span class="line">                    HeadAdjust(result, <span class="number">0</span>, j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result[k<span class="number">-1</span>] &gt; input[i])</span><br><span class="line">                    result[k<span class="number">-1</span>] = input[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对堆排序方法的优化，因为当遍历到第k个元素之后，若没有跟新result容器中的元素时，不用每次都执行一次对result容器的堆排序等操作。做了以下调整：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> parent, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = input[parent];</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">2</span>*parent + <span class="number">1</span>; <span class="comment">// 左树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (child&lt;length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (child+<span class="number">1</span> &lt; length &amp;&amp; input[child] &lt; input[child+<span class="number">1</span>])<span class="comment">// 判断左右树的大小</span></span><br><span class="line">                child++; <span class="comment">// 若条件成立，则说明右树大</span></span><br><span class="line">            <span class="keyword">if</span> (temp&gt;=input[child]) <span class="comment">// 若当前根结点大于等于最大左右子树，则直接跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            input[parent] = input[child]; <span class="comment">// 将较大的子树结点赋值给当前根结点</span></span><br><span class="line">            <span class="comment">// 对下一层进行大顶堆排序</span></span><br><span class="line">            parent = child;</span><br><span class="line">            child = <span class="number">2</span>*parent +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        input[parent] = temp; <span class="comment">// 将原根结点的值赋值给替换的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">bool</span> change = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (input.empty() || k &lt;= <span class="number">0</span> || k &gt; input.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历输入的n个整数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="built_in">size</span>() &lt; k) <span class="comment">// 若result中的元素小于k时直接存放在result容器中</span></span><br><span class="line">                result.push_back(input[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (change)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 对result容器中k个元素进行大顶堆排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = k/<span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                    HeadAdjust(result, j, k);  </span><br><span class="line">                <span class="comment">// 将无序的大顶堆进行有序排列,将堆顶与最后一个元素互换，然后对前k-1个元素进行大顶堆排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = k <span class="number">-1</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(result[<span class="number">0</span>],result[j]);</span><br><span class="line">                    HeadAdjust(result, <span class="number">0</span>, j);</span><br><span class="line">                &#125;</span><br><span class="line">                    change = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (result[k<span class="number">-1</span>] &gt; input[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    result[k<span class="number">-1</span>] = input[i];</span><br><span class="line">                    change = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_29.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_29.html</a></p><p><a href="https://www.icourse163.org/learn/XMU-1206002801?tid=1450366458#/learn/content?type=detail&amp;id=1214739254&amp;sm=1" target="_blank" rel="noopener">https://www.icourse163.org/learn/XMU-1206002801?tid=1450366458#/learn/content?type=detail&amp;id=1214739254&amp;sm=1</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中出现次数超过一半的数字</title>
      <link href="/a01a37fb.html"/>
      <url>/a01a37fb.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。若不存在则输出0.</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>要找的元素的出现次数是超过数组一半的，也就是说与该元素相同的值占据数组的一半之多。面对这种要求可以采用<strong>阵地攻守思想</strong>。真正守下阵地，并占据数组个数多于数组长度一半的元素，称为兵王。</p><ul><li>数组第一个元素作为第一个士兵，守阵地，此时这个小分队的成员人数count=1；</li><li>当遇到相同元素时，小分队人数 +1 count++；</li><li>当遇到不同的元素时，同归于尽，小分队人数 -1 count–；</li><li>当小分队人数为 0 时，换下一个元素组成新的小分队守护阵地，若上叙步骤进行。</li><li>当遍历完整个数组，当小分队中还有人在时，说明这个元素<strong>有可能</strong>是要找的。</li><li>再遍历整个数组，记录数组中这个元素的个数是否大于数组长度的一半。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">1</span>, result = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 找到最后坚守阵地的士兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (times==<span class="number">0</span>) <span class="comment">// 小分队全部牺牲，将当前元素作为新的小分队成员</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = numbers[i];</span><br><span class="line">                times = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] == result) <span class="comment">// 遇到相同的士兵，加入小分队</span></span><br><span class="line">                times++;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 遇到的是不同的敌人，同归于尽</span></span><br><span class="line">                times--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断最后坚守的士兵（元素），是否为真正要寻找的兵王</span></span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == result)</span><br><span class="line">                times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (times&gt;(length/<span class="number">2</span>) ? result : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考博文链接：<a href="https://www.nowcoder.com/questionTerminal/e8a1b01a2df14cb2b228b30ee6a92163?f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/e8a1b01a2df14cb2b228b30ee6a92163?f=discussion</a></p><p><a href="https://cuijiahua.com/blog/2017/12/basis_28.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_28.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的排序</title>
      <link href="/e6489f2a.html"/>
      <url>/e6489f2a.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列，列如输入字符串abc，则打印出所有排列出来的所有字符串abc，acb，bac，bca，cab，cba。</p><p>输入描述：输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>字典序：字典序不仅仅是比较英文字母，而是比较任意字符串。对于两个字符串，大小关系取决于两个字符串<strong>从左到右第一个不同字符的ASCLL值得大小关系</strong>。</p><p>可以考虑回溯排序的方法，方法示例如下：</p><p><img src="https://uploadfiles.nowcoder.com/images/20170705/7578108_1499250116235_8F032F665EBB2978C26C4051D5B89E90" alt="img"></p><blockquote><p>首先遍历所有字符，<strong>因为这些字符都会出现在第一个位置上进行固定。</strong>（即需要与第一个位置的字符交换）</p><p>然后，固定第一个字符，然后对后面的字符进行排列（即，通过递归的方法对剩余字符进行上述排列）</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> <span class="built_in">begin</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == <span class="built_in">begin</span>) <span class="comment">// 递归结束的条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="built_in">begin</span> &amp;&amp; str[<span class="built_in">begin</span>]==str[i]) <span class="comment">// 若遍历后面的字符与第一个元素相等则跳过该字符</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(str[<span class="built_in">begin</span>], str[i]);</span><br><span class="line">            Sort(str, <span class="built_in">begin</span>+<span class="number">1</span>);<span class="comment">// 递归剩余的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        Sort(str, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//排列完的结果，可能不是按照字典序排列的，需要重新排一下顺序</span></span><br><span class="line">        sort(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考链接：<a href="https://cuijiahua.com/blog/2017/12/basis_27.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_27.html</a></p><p><a href="https://www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7?f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7?f=discussion</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树转换为双向链表</title>
      <link href="/ed8bddee.html"/>
      <url>/ed8bddee.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一颗二叉搜索树，将该二叉搜索树转换成一个<strong>排序的</strong>双向链表。<strong>要求不能创建任何新的结点，只能调整树中结点指针的指向。</strong></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目有两个关键：</p><ul><li>转换为排序的链表；</li><li>不能创建新的结点，只能调整结点的指针指向；</li></ul><p>由于二叉树数值的大小分布为：左子树值 &lt; 根结点值 &lt;  右子树值。同时结合以上两个条件说明，遍历二叉树的输出结果，必须是按照大小排列好顺序的。这样的遍历就会想到，中序遍历二叉树的方法。</p><img src="/ed8bddee/image-20200525162249209.png" alt="image-20200525162249209" style="zoom:50%;"><p>这样通过中序遍历二叉树的输出结果就是链表的排列顺序，只需更改链表中的指针的指向，使其成为双向链表。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">    TreeNode (<span class="keyword">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConvertList</span><span class="params">(TreeNode* pNode, TreeNode** pLastNodeInList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* pCurrent = pNode;</span><br><span class="line">        <span class="comment">// 左子树递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> (pCurrent-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            ConvertList(pCurrent-&gt;left, pLastNodeInList);</span><br><span class="line">        <span class="comment">// 当前结点左指针建立</span></span><br><span class="line">        pCurrent-&gt;left = *pLastNodeInList;</span><br><span class="line">        <span class="comment">// 指向当前结点的右指针建立</span></span><br><span class="line">        <span class="keyword">if</span> (*pLastNodeInList != <span class="literal">NULL</span>)</span><br><span class="line">            (*pLastNodeInList)-&gt;right = pCurrent; <span class="comment">// 此处注意*pLastNodeInList的括号，优先级的问题</span></span><br><span class="line">        <span class="comment">// 完成新结点指针指向的操作后，更新链表尾结点</span></span><br><span class="line">        *pLastNodeInList = pCurrent;</span><br><span class="line">        <span class="comment">// 右子树递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> (pCurrent-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ConverList(pCurrent-&gt;right, pLastNodeInList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* pLastNodeInList = <span class="literal">NULL</span>; <span class="comment">// 创建双向链表的尾结点</span></span><br><span class="line">        <span class="comment">// 创建双向链表</span></span><br><span class="line">        ConvertList(pRootOfTree, &amp;pLastNodeInList);</span><br><span class="line">        <span class="comment">// 返回双向链表的头结点</span></span><br><span class="line">        TreeNode* pHeadOfList = pLastNodeInList;</span><br><span class="line">        <span class="keyword">while</span> (pHeadOfList != <span class="literal">NULL</span> &amp;&amp; pHeadOfList-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pHeadOfList = pHeadOfList-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHeadOfList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下是转换过程中，指针指向的变换过程：</p><img src="/ed8bddee/image-20200525165225182.png" alt="image-20200525165225182" style="zoom:67%;"><p>关于<code>ConvertList()</code>函数中<code>pLastNodeInList</code>为什么要用双指针的问题。</p><blockquote><p>因为定义了双链表的尾结点为<code>pLastNodeInList</code>，通过尾插法把二叉树的结点依次插入链表中。期间定义的链表的尾结点<code>pLastNodeInList</code>要时刻移动，因为<code>pLastNodeInList</code>定义的是一个<strong>指针</strong>，对指针的值进行操作就需要对其地址进行操作。</p></blockquote><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_26.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_26.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂链表的复制</title>
      <link href="/68dc24ea.html"/>
      <url>/68dc24ea.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个复杂链表（每个结点中有结点值，以及两个指针，一个指向下一个结点，另一个特殊指针random指向一个随机结点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意：输出结果中不要返回此参数中的结点引用，否则判断题程序会直接返回空）</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先复制链表的结点值和指向下一个结点的指针，最后再复制random指针。查找random指针分为两种：一种是每次都从头开始遍历查找，时间复杂度为 <code>O(n^2)</code>；另一种是空间换时间，复制结点值和指向下一个结点指针的同时，创建一个hash表来存放新旧复杂指针的对应关系，只要一步就可以查找到random，时间复杂度为<code>O(n)</code>。</p><p>将复制的过程分为以下三步：</p><ul><li>复制复杂指针的，结点值和next指针。把复制的结点直接插入到原结点的后面；</li><li>设置复制出来新结点的random指针。因为新旧链表是前后对应关系，所以也可以一步直接找到random；</li><li>拆分链表。</li></ul><p>步骤示例图：</p><img src="/68dc24ea/image-20200525102544767.png" alt="image-20200525102544767" style="zoom:67%;"><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span> *<span class="title">next</span>, *<span class="title">random</span>;</span></span><br><span class="line">    RandomListNode (<span class="keyword">int</span> x): label(x), next(<span class="literal">NULL</span>), <span class="built_in">random</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 第一步，先复制label和next</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* pNode = pHead;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* pCloned = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">            pCloned-&gt;label = pNode-&gt;label;</span><br><span class="line">            pCloned-&gt;next = pNode-&gt;next;</span><br><span class="line">            pCloned-&gt;<span class="built_in">random</span> = <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">            pNode-&gt;next = pCloned; <span class="comment">// 将复制结点插入到原结点之后</span></span><br><span class="line">            pNode = pCloned-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二步，找到新结点的random</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindrandomNodes</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* pNode = pHead;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* pCloned = pNode-&gt;next; <span class="comment">// 新链表的头结点</span></span><br><span class="line">            <span class="keyword">if</span> (pNode-&gt;<span class="built_in">random</span> != <span class="literal">NULL</span>)</span><br><span class="line">                pCloned-&gt;<span class="built_in">random</span> = pNode-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">            </span><br><span class="line">            pNode = pCloned-&gt;next; <span class="comment">// 移动到原链表中下一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三步，拆分链表</span></span><br><span class="line">    <span class="function">RandomListNode* <span class="title">ReconnectNodes</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* pNode = pHead;</span><br><span class="line">        RandomListNode* pClonedHead = <span class="literal">NULL</span>;</span><br><span class="line">        RandomListNode* pClonedNode = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="literal">NULL</span>) <span class="comment">// 确定新链表的头结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            pClonedHead = pClonedNode = pNode-&gt;next;</span><br><span class="line">            pNode-&gt;next = pClonedNode-&gt;next;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pClonedNode-&gt;next = pNode-&gt;next;</span><br><span class="line">            pClonedNode = pClonedNode-&gt;next;</span><br><span class="line">            pNode-&gt;next = pClonedNode-&gt;next;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pClonedHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CloneNodes(pHead);</span><br><span class="line">        FindrandomNodes(pHead);</span><br><span class="line">        <span class="keyword">return</span> ReconnectNodes(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_25.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_25.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中和为某一值路径</title>
      <link href="/d8629079.html"/>
      <url>/d8629079.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一颗二叉树得根结点和一个整数，打印出二叉树中结点值得和为输入整数得所有路径。路径定义为从树得根结点开始往下一直到叶结点所经过得结点形成一条路径。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>深度优先搜索，采用前序遍历的方法。</p><p>可以通过设置两个容器，一个存放临时容器tmp结果，另一个result容器存放最终结果。</p><p>把当前的根结点存入tmp容器中，如果当前的根结点<strong>同时</strong>满足以下条件则说明是一条满足条件的路径：</p><ul><li>输入的整数等于当前根结点的值；</li><li>当前根结点没有左子树；</li><li>当前根结点没有右子树；</li></ul><p>其中后两个条件是题目中提到，<strong>根结点开始往下一直到 ** *</strong>叶结点***  所经过的结点形成一条路径。</p><p>然后通过递归的方法判断左右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    TreeNode (<span class="keyword">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">FindPath</span><span class="params">(TreeNode *root, <span class="keyword">int</span> expectNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (expectNumber-root-&gt;val==<span class="number">0</span> &amp;&amp; root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root-&gt;left, expectNumber - root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right, expectNumber - root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_24.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_24.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的后序遍历序列</title>
      <link href="/b31dcda.html"/>
      <url>/b31dcda.html</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，判断该数组是否为某二叉树搜索树的后序遍历的结果。如果是输出Yes，否则输出No。假设输入的数组的任意两个数字都是互不相同的。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>二叉树分左右子树，不可交换。通过大小来区分左右子树。左子树的根节点小于根节点；右子树的根节点大于根节点。</p><p>后序遍历：从叶子结点开始，从左子树到右子树依次遍历，最后遍历根结点。</p><img src="/b31dcda/image-20200524112004913.png" alt="image-20200524112004913" style="zoom:50%;"><p>根据后序遍历的原理可知，后序遍历输出序列，除<strong><em>最后一个元素为根结点</em></strong>外，分为两段，前半段为小于根节点的左子树，后半段为大于根结点的右子树。</p><p>然后可以根据后续遍历输出序列的特点，来判断输入的数组是否为该树的后序遍历。</p><p><strong><em>主要是先保证数组元素小于根结点的左子树先正确，然后判断剩余的元素是否满足右子树的要求（大于根结点）</em></strong></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sub(sequence, <span class="number">0</span>, sequence.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (seq.<span class="built_in">size</span>()==<span class="number">0</span> || <span class="built_in">begin</span>&gt;<span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">begin</span>; <span class="comment">// i就是左右子树的分界值</span></span><br><span class="line">        <span class="comment">// 分出左树</span></span><br><span class="line">        <span class="keyword">for</span> (;i &lt; <span class="built_in">end</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[i] &gt; seq[<span class="built_in">end</span>]) <span class="comment">// 大于根结点则跳出该循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看右树是否满足后续遍历要求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j&lt;<span class="built_in">end</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[j] &lt; seq[<span class="built_in">end</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左子树是否满足后序遍历要求</span></span><br><span class="line">        <span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="built_in">begin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = sub(seq, <span class="built_in">begin</span>, i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断右子树是否满足后序遍历要求</span></span><br><span class="line">        <span class="keyword">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right = sub(seq, i, <span class="built_in">end</span><span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right; <span class="comment">// 只有左右子树都满足后续遍历要求才为真</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_23.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_23.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 后序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依次打印二叉树结点</title>
      <link href="/3db0c412.html"/>
      <url>/3db0c412.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>从上到下打印出二叉树的每个节点，同层节点从左至右打印。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目的要求时从上到下，每层从左到右，即按层依次输出。</p><p>通过队列实现二叉树的遍历，同样还有图的遍历也可以使用这个方法。</p><p>这需要借助<strong>队列（queue）</strong>来进行排序输出。然后把输出结果存放到一个vector容器中。把每层结点依次放到队列中，然后依次输出。</p><ul><li><p>先把根结点存入队列</p></li><li><p>只要队列不为空则执行以下步骤；</p><ul><li>把队列的头结点压入到vector容器中</li><li>若队列的头结点的左结点不为空，则将左结点存入队列中</li><li>若队列的头结点的右结点不为空，则将右结点存入队列中</li><li>然后删除队列的头结点</li></ul></li><li><p>输出vector容器；</p></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">    TreeNode (<span class="keyword">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        Q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode * tmp;</span><br><span class="line">            tmp = Q.front(); <span class="comment">// 临时值赋值队列的头结点</span></span><br><span class="line">            result.push_back(tmp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                Q.push(tmp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                Q.push(tmp-&gt;right);</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; Q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_22.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_22.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断是否为栈的弹出顺序</title>
      <link href="/b53ac718.html"/>
      <url>/b53ac718.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相同。</p><p>例如序列1，2，3，4，5是某栈的压入顺序，序列4，5，3，2，1是该压栈序列对应的一个弹出序列，但是4，3，5，1，2就不可能是该压栈序列的弹出序列。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>设一个辅助栈S，用来判断。</p><ul><li><p>若栈A为空，则直接把压入序列A的第一个元素压入栈S。</p></li><li><p>将压入序列A的元素依次压入栈S中；</p><ul><li>若栈S的栈顶元素与弹出序列B的第一个元素相等，则弹出栈S中的元素，弹出序列B移动到下一个元素；</li></ul></li><li><p>然后判断辅助栈S是否为空，若为空则序列B是弹出顺序；否则不是。</p></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>  (pushV.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> num = pushV.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            A.push(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span> (j &lt; popV.<span class="built_in">size</span>() &amp;&amp; A.top() == popV[j]) <span class="comment">// &amp;&amp;两边的内容不可替换</span></span><br><span class="line">            &#123;</span><br><span class="line">                A.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当<code>while()</code>语句的判断条件中&amp;&amp;两边内容互换后，会出现数组越界的现象。<strong><em>因为只有当 <code>j</code>不大于 <code>popV</code>数组中的个数时，才能进行<code>popV[j]</code>的操作。</em></strong></p><hr><p>参考链接：<a href="https://cuijiahua.com/blog/2017/12/basis_21.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_21.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定义栈并得到最小元素</title>
      <link href="/e36e3ebc.html"/>
      <url>/e36e3ebc.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度为<code>O(1)</code>.保证测试中不会当栈为空的时候，对栈调用<code>pop() min() top()</code>方法。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>可以通过两个栈来实现栈的数据结构。一个栈Data存放数据，另一个栈Min存放最小值。</p><ul><li><strong>入栈</strong>：直接将数据压入数据栈Data中。若最小栈Min<strong>为空</strong>直接将数据压入。若Min栈<strong>不为空</strong>将当前值与栈顶部元素比较，若较小则压入Min栈；否则不做处理。</li><li><strong>出栈</strong>：若数据栈Data和最小栈Min的栈顶元素相同，则弹出Min栈顶元素，同时弹出数据栈Data栈顶元素；否则弹出数据栈Data栈顶元素。</li><li><strong>栈顶元素</strong>：直接用数据栈Data的栈顶元素</li><li><strong>最小元素</strong>：直接调用最小栈Min的栈顶元素</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Data.push(value);</span><br><span class="line">        <span class="keyword">if</span> (Min.empty())</span><br><span class="line">            Min.push(value);</span><br><span class="line">        <span class="keyword">if</span> (Min.top() &gt; value)</span><br><span class="line">            Min.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Data.empty()) <span class="comment">//栈不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Data.top() == Min.top())</span><br><span class="line">                Min.pop();</span><br><span class="line">            Data.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Data.empty())</span><br><span class="line">            <span class="keyword">return</span> Data.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Data.empty())</span><br><span class="line">            <span class="keyword">return</span> Min.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_20.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_20.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针输出矩阵的值（C++）</title>
      <link href="/d660613.html"/>
      <url>/d660613.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="刷题平台"><a href="#刷题平台" class="headerlink" title="刷题平台"></a>刷题平台</h1><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如输入一个4×4矩阵：1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16则依次打印出的数字1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10.</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>依次遍历输出的过程：</p><ul><li>从左上角开始<strong>从左到右</strong>依次遍历输出；</li><li><strong>从上到下</strong>依次遍历输出；</li><li><strong>从右到左</strong>依次遍历输出；</li><li><strong>从下到上</strong>依次遍历输出；</li></ul><p><img src="/d660613/image-20200522102341218.png" alt></p><p><strong>其中黄色为遍历的起点，红色为遍历的终点。</strong></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result; <span class="comment">// 用于存放输出的结果</span></span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>) <span class="comment">// 判断矩阵是否为空</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = col <span class="number">-1</span>, top = <span class="number">0</span>, bottom = row - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) <span class="comment">// 判断矩阵是否遍历完</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) <span class="comment">//从左向右，注意i 的范围</span></span><br><span class="line">                result.push_back(matrix[top][i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++) <span class="comment">// 从上到下，注意i的范围</span></span><br><span class="line">                result.push_back(matrix[i][right]);</span><br><span class="line">            <span class="keyword">if</span> (top != bottom) <span class="comment">//若top == bottom 则没有必要再从右向左遍历，因为已经遍历过了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; i--) <span class="comment">// 从右向左，注意i的范围。</span></span><br><span class="line">                    result.push_back(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left != right) <span class="comment">// 若left==right则没必要从下到上遍历，因为已经遍历过了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; i--)<span class="comment">// 从下向上，注意i的范围</span></span><br><span class="line">                    result.push_back(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++,right--,top++,bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断二叉树的子树（C++）</title>
      <link href="/19201b09.html"/>
      <url>/19201b09.html</url>
      
        <content type="html"><![CDATA[<h1 id="刷题平台"><a href="#刷题平台" class="headerlink" title="刷题平台"></a>刷题平台</h1><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两棵二叉树A,B，判断B是不是A的子树。（PS：约定空树不是任意一个树的子树）</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>若A树和B树有一个为空树，则可判断B树不是A树的子结构；</li><li>判断B树的根节点是否在A树中是否有相等值；</li><li>当A树中含有B树的根节点，然后再判断A树该节点以下的结构是否和B树结构是否相同；</li><li><ul><li>若B树先遍历完，而A树还没有遍历完（其中所有节点都相等），则B树为A树的子结构；</li></ul></li><li><ul><li>若A树先遍历完，而B树还没有遍历完（其中所有节点都相等），则B树不是A树的子结构；</li></ul></li><li><ul><li>若再遍历的时候有不相等节点，则B树不是A树的子结构；</li><li><strong><em>以上三步的执行顺序不能改变</em></strong>，</li></ul></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    TreeNode (<span class="keyword">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> TreeNode *<span class="title">HasSubtree</span><span class="params">(TreeNode *pRoot1, TreeNode *pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pRoot1-&gt;val == pRoot2-&gt;val)<span class="comment">// 若树A根节点和树B根节点相同</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = DoseTree1HasTree2(pRoot1, pRoot2);<span class="comment">// 进行余下节点判断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!result) <span class="comment">// A的根节点和B根节点不同，则继续判断A的左树</span></span><br><span class="line">                result = HasSubtree(pRoot1-&gt;left, pRoot2);</span><br><span class="line">            <span class="keyword">if</span> (!result)<span class="comment">// A的左树节点和B树的根节点不同，则继续判断A的右树</span></span><br><span class="line">                result = HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DoseTree1HasTree2</span><span class="params">(TreeNode *pRoot1, TreeNode *pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot2 == <span class="literal">NULL</span>) <span class="comment">//若先遍历完B树，则B是A的子结构</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">NULL</span>) <span class="comment">// 若先遍历完A树，则B不是A的子结构</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1-&gt;val != pRoot2-&gt;val) <span class="comment">//若遍历A和B时有不相等的值，则B不是A的子结构</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 遍历过程中 A和B都没有先遍历完，然后通过递归判断左，右子树是否相同</span></span><br><span class="line">        <span class="keyword">return</span> DoseTree1HasTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; DoseTree1HasTree2(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中再<code>bool DoseTree1HasTree2()</code>中的<code>if(pRoot1 == NULL) return false;</code>和<code>if(pRoot2 == NULL) return true;</code>交换后会出现错误。</p><p>因为<code>bool TreeNode *HasSubtree()</code>规定，pRoot1 和 pRoot2 不能同时为空，才能继续执行。</p><p>当交换代码的顺序后，即先判断<code>pRoot1</code>为空，可能会忽略一种情况，即<code>pRoot2</code>也为空的情况。不满足<code>HasSubtree()</code>中的执行条件<code>pRoot1 != NULL &amp;&amp; pRoot2 != NULL</code></p><p><strong><em>以上解释来源于网络，但是自己还是想不通！</em></strong></p><hr><p>参考博文链接：<a href="https://www.nowcoder.com/questionTerminal/6e196c44c7004d15b1610b9afca8bd88?f=discussion" target="_blank" rel="noopener">牛客网</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并顺序链表（C++）</title>
      <link href="/6e4526ea.html"/>
      <url>/6e4526ea.html</url>
      
        <content type="html"><![CDATA[<h1 id="刷题平台"><a href="#刷题平台" class="headerlink" title="刷题平台"></a>刷题平台</h1><p><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入连个单调递增的链表，输出两个链表合成后的链表，并保证新的链表是非单调递减的。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>当链表 1 为空，则直接返回链表 2 ；当链表 2 为空时，直接返回链表 1；当链表 1链表 2都为空时，返回空。</li><li>判断两个链表的头结点的大小，将较小的结点放入新链表。然后通过递归的方法，遍历两个链表。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">Merge</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode *NewMerge = <span class="literal">NULL</span>; <span class="comment">// 新链表</span></span><br><span class="line">        <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) <span class="comment">// 判断两链表的头结点的大小</span></span><br><span class="line">        &#123;</span><br><span class="line">            NewMerge = pHead1;</span><br><span class="line">            NewMerge-&gt;next = Merge(NewMerge-&gt;next, pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            NewMerge = pHead2;</span><br><span class="line">            NewMerge-&gt;next = Merge(pHead1, NewMerge-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NewMerge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_16.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_16.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表（C++）</title>
      <link href="/972829f4.html"/>
      <url>/972829f4.html</url>
      
        <content type="html"><![CDATA[<h1 id="刷题平台"><a href="#刷题平台" class="headerlink" title="刷题平台"></a>刷题平台</h1><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，反转链表后输出新链表的表头。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目中给出的<strong>输出新链表的表头</strong>，根据给出的代码初定义<code>ListNode *ReverseList(ListNode *pHead) {}</code>可知这个“表头”的含义不是指单一的元素，而是反转后的整个链表。（<strong><em>自己理解，不知对错</em></strong>）</p><ul><li>通过三个指针来完成反转，pCurr是指向当前结点的指针，pPre指向当前结点之前的结点，pNext指向当前结点之后的结点。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">ReverseList</span><span class="params">(ListNode *pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *NewHead = <span class="literal">NULL</span>; <span class="comment">// 反转后的链表</span></span><br><span class="line">        ListNode *pCurr = pHead;</span><br><span class="line">        ListNode *pPre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (pCurr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *pNext = pCurr-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (pNext == <span class="literal">NULL</span>)</span><br><span class="line">                NewHead = pCurr;</span><br><span class="line">            pCurr-&gt;next = pPre; <span class="comment">// 反转，即将当前结点的指针由指向next指向pre</span></span><br><span class="line">            pPre = pCurr;</span><br><span class="line">            pCurr = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NewHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行的过程</p><p><img src="/972829f4/image-20200521101120677.png" alt="image-20200521101120677"></p><p>​    P为当前结点的前一个指针，C为当前结点的指针，N为当前结点的下一个指针。</p><hr><p>参考文献：<a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输出链表的倒数第k个结点（C++）</title>
      <link href="/1c380935.html"/>
      <url>/1c380935.html</url>
      
        <content type="html"><![CDATA[<h1 id="刷题平台"><a href="#刷题平台" class="headerlink" title="刷题平台"></a>刷题平台</h1><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个链表，输出链表中倒数第k个结点。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>假设两个指针p1，p2，两个指针都指向链表的头指针。</p><p>p1指针依次遍历链表，直到移动到第 k 个结点时，p2指针开始从表头开始遍历。</p><p>p1和p2两指针继续<strong><em>同时</em></strong>往后遍历（<strong>p1和p2两指针的间隔是固定的</strong>），直到p1指针指向边表末尾时，p2指针指向的结点就是链表中倒数第 k 个结点。</p><p>以下链表输出倒数第2个结点，</p><p>p1指针指向第2个结点，p2指针指向第1个结点。<img src="/1c380935/image-20200520213343088.png" alt="image-20200520213343088" style="zoom:50%;"></p><p>p1和p2指针同时向后遍历，直到链表末尾。<img src="/1c380935/image-20200520213545576.png" alt="image-20200520213545576" style="zoom:50%;"></p><p>p2指针指向的结点就是要输出的倒数第 2 个结点。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">FindKthToTail</span><span class="params">(ListNode *pListHead, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pListHead == <span class="literal">NULL</span> || k == <span class="number">0</span>) <span class="comment">// 链表为空或要求输出的结点位置不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *p1 = pListHead;</span><br><span class="line">        ListNode *p2 = pListHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++) <span class="comment">// 得到p1指向第 k 个结点的指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1-&gt;next != <span class="literal">NULL</span>) <span class="comment">// p1,p2指针同时向后遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/12/basis_14.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/12/basis_14.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调整数组奇数在前偶数在后（C++）</title>
      <link href="/558b5743.html"/>
      <url>/558b5743.html</url>
      
        <content type="html"><![CDATA[<h1 id="刷题平台"><a href="#刷题平台" class="headerlink" title="刷题平台"></a>刷题平台</h1><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个整数数组，实现一个函数来调整改数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并<strong>保证奇数和奇数，偶数和偶数之间的相对位置不变</strong>。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>根据题意可知将数组分为两个部分，可以考虑两端都可插入的<strong>双向数组deque容器</strong>。</p><p>然后通过使用vector容器的赋值操作<code>assign</code>把deque容器的值赋值给vector容器array。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[<span class="built_in">size</span><span class="number">-1</span>-i] % <span class="number">2</span> == <span class="number">1</span>) <span class="comment">// 向前插入奇数时，为了保证奇与奇的相对位置，需倒序遍历</span></span><br><span class="line">                result.push_front(<span class="built_in">array</span>[<span class="built_in">size</span><span class="number">-1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>.assign(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>vector容器中的<code>assign(beg, end)</code>即将[beg, end]区间的值赋值给本身。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值得整数次方（C++版）</title>
      <link href="/5ba1c33c.html"/>
      <url>/5ba1c33c.html</url>
      
        <content type="html"><![CDATA[<h1 id="刷题平台"><a href="#刷题平台" class="headerlink" title="刷题平台"></a>刷题平台</h1><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个double类型得浮点数base和int类型得整数exponent。求base得exponent次方。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>当指数为正时，就是正常得求解方法。指数为负时，则是按正值的倒数。若底数为 0 ，则直接返回 0 .</p><p>此时要<strong><em>注意</em></strong>：用计算机表示小数（float和double）都有误差，<strong>不能直接用等号（==）判断两个小数是否相等</strong>。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为他们相等。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (equal(base, <span class="number">0.0</span>) &amp;&amp; exponent == <span class="number">0</span>) <span class="comment">// 保证base和exponent不能同时为 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (equal(base, <span class="number">0.0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(exponent); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &gt; <span class="number">0</span>)</span><br><span class="line">            result = result;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = <span class="number">1</span>/result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num2 - num1 &lt; <span class="number">0.0000001</span> &amp;&amp; (num1 - num2) &lt; <span class="number">0.0000001</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>当使用了<code>equal()</code>函数来判断小数是否相等时，与直接用等号（==）时，计算时间多了 <code>1ms</code>.(<strong>此结果只是本人自己运行的结果，不具备普遍性，仅供参考</strong>)</p><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/11/basis_12.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/11/basis_12.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整数次方 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在二进制中寻找1的个数（C++版）</title>
      <link href="/9ce48081.html"/>
      <url>/9ce48081.html</url>
      
        <content type="html"><![CDATA[<h1 id="刷题平台"><a href="#刷题平台" class="headerlink" title="刷题平台"></a>刷题平台</h1><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表中1的个数。其中负数用补码表示。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>由整数转换为二进制数后，可知任何一个<strong><em>非零整数，转换为二进制后至少含有一个  1</em></strong>.</p><p><strong><em>将转换后的二进制中最右边的 1 元素，进行完二进制数减 1 后变为 0 ，后面的 0 全部变为 1 ，之前的元素不变. 将减 1 后的二进制数与原二进制数进行与操作，的到的结果就是将最右边的 1 去掉后的二进制数。</em></strong>每进行一次这样的操作，就相当于二进制中有一个 1 .</p><p>例如：转换后的二进制数为 10010. 将最右边的 1 减去后变成 10001，10001&amp;10010 = 10000，可知每完成一次这样的操作，二进制中便有一个元素 1 .</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            count += <span class="number">1</span>; <span class="comment">// 也可以是++count，count++,</span></span><br><span class="line">            n = (n<span class="number">-1</span>) &amp; n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>补码：</p><p>正数的补码是其二进制表示，即与源码相同。</p><p>负数的补码是将其原码的所有位取反，然后加 1 .</p><p>O的补码是唯一的，即为 0 .</p><hr><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/11/basis_11.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/11/basis_11.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求旋转数组最小值(C++版)</title>
      <link href="/ea94afe4.html"/>
      <url>/ea94afe4.html</url>
      
        <content type="html"><![CDATA[<h1 id="刷题平台"><a href="#刷题平台" class="headerlink" title="刷题平台"></a>刷题平台</h1><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个<strong>非递减</strong>排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，改数组的最小值为1.<strong>注意</strong>：给出的所有元素都大于0，若数组大小为0，请返回0.</p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p><strong>非递减</strong>：说明输入的数组不是递增的就是含有多个相等的元素构成。</p><p><strong>递增排序情况</strong>：</p><p>由于输入的是一个旋转数组，意味着<strong>原始数组前较小的元素移动到数组末尾</strong>，因此可以确定旋转后的数组<strong>第一个元素一定是大于最后一个元素的</strong>。如果不满足这个条件，则说明不是旋转数组。（<strong>这可以作为判断数组是否旋转的条件</strong>）</p><p>查找数组中的最小元素：这个可以根据数据结构中的查找选择合适的方法。由于数组是递增排序的，因此数组可以看成在有序表中进行查找。</p><p>有序表中查找的方法：二分查找，插值查找，斐波那契查找。三种方法的时间复杂度都是<code>O[logn]</code></p><blockquote><p>二分法：</p><p><strong>优点</strong>：对于静态的查找表进行查找，这种算法比较好</p><p><strong>缺点</strong>：对于频繁插入删除的顺序表来说，这种算法就不建议使用</p></blockquote><blockquote><p>插值查找：</p><p><strong>优点</strong>：对于顺序表较长，且表中的元素大小分布均匀（元素值之间相差较小），较二分法要好。</p><p><strong>缺点</strong>：当数组中的元素大小分布不均匀时（例如{1，2，9999，99999}），这种算法效率就比较差。</p></blockquote><blockquote><p>斐波那契查找：</p><p><strong>优点</strong>：这种算法在查找过程中仅仅进行最简单的加减法运算，在大量数据下查找，会占有优势。</p><p><strong>缺点</strong>：虽然这种算法的平均查找性能优于二分法，但是如果查找的关键字位于较长的半区，则查找效率要低于二分法。</p></blockquote><p>通过分析得知：旋转数组是一个<strong>静态数组</strong>，但是数组中的<strong>元素大小分布不确定</strong>，<strong>最小元素的位置也不确定</strong>，因此选择二分查找法是不错的选择。</p><ul><li><p>旋转数组可以看成两个递增序列。</p></li><li><p>取两个指针分别指向第一个元素和最后一个元素。<img src="/ea94afe4/image-20200519153003545.png" alt="image-20200519153003545" style="zoom:50%;"></p></li><li><blockquote><p>在数组中取中间元素作为比较对象，若中间值大于第一个元素，则说明中间值在前面一个递增序列中，将第一个指针指向中间元素；<img src="/ea94afe4/image-20200519153222647.png" alt="image-20200519153222647" style="zoom:50%;"></p><p>若中间值小于最后一个元素，则说明中间值在后面一个递增序列中，则将第二个指针指向中间元素。</p><img src="/ea94afe4/image-20200519153525515.png" alt="image-20200519153525515" style="zoom:50%;"><p>循环以上步骤。</p><p>当两个指针指向相邻元素时，右指针指向的元素就是最小值。</p><img src="/ea94afe4/image-20200519153649161.png" alt="image-20200519153649161" style="zoom:50%;"></blockquote></li></ul><p><strong>含有多个相等元素</strong>：</p><p>由于含有多个相等元素，可能造成取得中间元素可能与第一个元素相等或与最后一个元素相等，即<strong>不能判断所取得中间元素是属于前一个递增序列还是后一个递增序列</strong>。<img src="/ea94afe4/image-20200519161121365.png" alt="image-20200519161121365" style="zoom:50%;"></p><p>此时就要通过使用<strong>顺序查找</strong>的方法，寻找最小值。</p><p>以下是代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rotateArray)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = rotateArray.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, mid = <span class="number">0</span>, right = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[left] &gt;= rotateArray[right]) <span class="comment">// 旋转数组的判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left == <span class="number">1</span>)   <span class="comment">// 左右指针指向相邻元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                mid = right;    <span class="comment">// 指向右面的指针的元素为最小值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[mid] == rotateArray[left]) <span class="comment">// 当取的中间值与左右指针指向的元素相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> minNum(rotateArray, left, right); <span class="comment">// 顺序查找</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rotateArray[mid] &gt;= rotateArray[left])</span><br><span class="line">                left = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = num[left];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) <span class="comment">// 只需遍历除去第一个和最后一个的中间数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; num[i])</span><br><span class="line">            &#123;</span><br><span class="line">                result = num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考博文链接：<a href="https://cuijiahua.com/blog/2017/11/basis_6.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/11/basis_6.html</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/ee040603.html"/>
      <url>/ee040603.html</url>
      
        <content type="html"><![CDATA[<hr><hr><p>图是由顶点（vertex）的<strong>有穷非空集合</strong>和顶点之间的边（edge）的集合组成。</p><h1 id="图的定义与术语"><a href="#图的定义与术语" class="headerlink" title="图的定义与术语"></a>图的定义与术语</h1><h2 id="无向图："><a href="#无向图：" class="headerlink" title="无向图："></a><strong>无向图：</strong></h2><img src="/ee040603/image-20200430105923334.png" alt="image-20200430105923334" style="zoom:50%;"><p>任意两个顶点之间的边没有方向，则称这条边为无向边，由无向边组成的图称为无向图。</p><p>无向边用无序偶对 <img src="/ee040603/image-20200430111911606.png" alt="image-20200430111911606" style="zoom: 50%;">来表示。</p><h2 id="有向图："><a href="#有向图：" class="headerlink" title="有向图："></a><strong>有向图：</strong></h2><img src="/ee040603/image-20200430112047552.png" alt="image-20200430112047552" style="zoom:50%;"><p>有向图：任意一条边都是有方向的，则这条边是有向边，也成为弧（Arc），这样的图称为有向图。</p><p>有向边通过有序偶&lt;vi, vj&gt;来表示。其中<code>vi</code>称为弧尾，<code>vj</code>称为弧头。 </p><h2 id="简单图："><a href="#简单图：" class="headerlink" title="简单图："></a><strong>简单图：</strong></h2><p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。</p><img src="/ee040603/image-20200430143132339.png" alt="image-20200430143132339" style="zoom:50%;"><p>上图就不是简单图。</p><h2 id="完全图："><a href="#完全图：" class="headerlink" title="完全图："></a><strong>完全图：</strong></h2><p><strong>无向图</strong>中任意两个顶点之间都存在边，则称为无向完全图。n个顶点含有<img src="/ee040603/image-20200430143513766.png" alt="image-20200430143513766" style="zoom: 33%;"></p><p>条边。</p><p><strong>有向图</strong>中任意两个顶点之间都存在<strong>方向互为相反</strong>的两条弧，则称该图为有向完全图。</p><p>n个顶点含有 <code>n ×（n - 1）</code>条边。</p><p><strong>网：</strong></p><p>图中的边或弧带有相关的数叫做权（weight），这种带权的图通常称为网（Network）。</p><img src="/ee040603/image-20200430144357455.png" alt="image-20200430144357455" style="zoom:50%;"><h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a><strong>子图</strong></h2><p><img src="/ee040603/image-20200430144524582.png" alt="image-20200430144524582"></p><p>灰色部分的图是左侧图的<strong>子图</strong>。</p><p><strong>路径的长度是路径上边或弧的数目。</strong></p><p><strong>第一个顶点到最后一个顶点相同的路径称为回路或环。</strong>序列中除了第一个和最后一个顶点之外，<strong>其他顶点不重复出现</strong>的回路，称为简单回路或简单环。</p><p>序列中顶点不重复出现的路径称为简单路径。</p><img src="/ee040603/image-20200430150658182.png" alt="image-20200430150658182" style="zoom:50%;"><h2 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h2><p>图中<strong>任意</strong>两个顶点之间都有路径的图，称为连通图（Connected Graph）。<strong>无向图</strong>称为<strong>连通图</strong>；<strong>有向图</strong>称为<strong>强连通图</strong>。</p><p>图中的<strong>极大连通子图</strong>称为连通分量。<strong>无向图</strong>称为连通分量；<strong>有向图</strong>称为<strong>强连通分量。</strong></p><p>需要注意的是：</p><ul><li>必须是子图</li><li>子图必须是连通的</li><li>连通子图含有极大的顶点数，以及依附于这些顶点的所有边</li></ul><h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>连通图的生成树是一个<strong>极小的连通子图</strong>，它含有图中全部的<strong><code>n</code>个顶点</strong>，但只有足以构成一棵树的 <strong><code>n-1</code> 条边</strong>。</p><p>由此可知，当含有<code>n</code>个顶点，但是边的条数小于<code>n - 1</code>时，则是非连通图；但是如果多于<code>n-1</code>条边，必定构成一个环。</p><p><strong>但是含有<code>n-1</code>条表的图，不一定是生成树。</strong></p><img src="/ee040603/image-20200430153622194.png" alt="image-20200430153622194" style="zoom:50%;"><p>图2，图3是图1的最小生成树，但是图4尽管含有<code>n-1</code>条边的条件，但是它<strong>不是生成树。</strong></p><p>有向树：</p><p>若一个<strong>有向图恰有一个顶点的入度为0，其余顶点的入度为1</strong>，则是一棵有向树。</p><p>一棵有向树的生成森林由若干棵有向树组成，含有图中全部顶点，但<strong>只有足以构成若干棵不相交的有向树的弧</strong>。</p><img src="/ee040603/image-20200430155144479.png" alt="image-20200430155144479" style="zoom:50%;"><p>图2和图3是图1的两棵有向树（<strong>只是一种情况</strong>）其中由有向树的定义可知，B与A,C要在一起，F要和E,G在一起。</p><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此不能通过使用内存中的物理位置来表示元素之间的关系。但是幸运的是前人已经提出了五种不同的解决办法。</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>图是由顶点和边或弧两部分组成的，为了方便，分别表示边（弧）和顶点。</p><p>因为顶点不分大小主次，所以用一个一维数组存储。</p><p>边（弧）是由两个顶点决定的，因此需要一个二位数组来存储。</p><p>于是提出了<strong>邻接矩阵（Adjacency Matrix）</strong>的概念。</p><p><strong>图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组存储图中的边或弧的信息。</strong></p><p>图中有<code>n</code>个顶点，则二维邻接矩阵是一个<code>n×n</code>的方阵，<img src="/ee040603/image-20200430163226350.png" alt="image-20200430163226350" style="zoom:33%;"></p><img src="/ee040603/image-20200430163304399.png" alt="image-20200430163304399" style="zoom:50%;"><p>通过这个邻接矩阵可以知道以下信息：</p><ul><li>判断任意两个顶点是否有边无边就非常容易</li><li>可以通过特定顶点在邻接矩阵中相应的行（列）的元素之和就可以判断此顶点的度。</li><li>求特定顶点的邻接点，只要遍历邻接矩阵中相应行元素，值为1就是邻接点。</li></ul><img src="/ee040603/image-20200430163915816.png" alt="image-20200430163915816" style="zoom:50%;"><p>对于有向图，同样也可以通过邻接矩阵，<strong>得到特定顶点的入度、出度以及邻接点等信息</strong>。</p><p>对于<strong>网</strong>来说，就需要额外的考虑与边相关的权值了。</p><p>相应的邻接矩阵计算公式如下：</p><img src="/ee040603/image-20200430165024863.png" alt="image-20200430165024863" style="zoom:50%;"><img src="/ee040603/image-20200430165240535.png" alt="image-20200430165240535" style="zoom:50%;"><p>对于<code>n</code>个顶点和<code>e</code>条边的无向网图的创建，<strong>时间复杂度</strong>为<code>O(n＋n^2+e)</code>其中对邻接矩阵的初始化耗费了<code>O(n^2)</code>的时间。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><img src="/ee040603/image-20200430171931057.png" alt="image-20200430171931057" style="zoom:50%;"><p>对于上图来说，使用邻接矩阵来说就存在存储空间的极大浪费。</p><p>因此考虑对边或弧使用<strong>链式存储</strong>的方式来避免空间的浪费问题。</p><p>通过使用数组来存储顶点信息，使用链表的形式来存储边或弧的信息的存储方式，称作<strong>邻接表（Adjacency List）</strong></p><p>邻接表的处理办法：</p><ul><li>图中的顶点用一个一维数组存储，同时，每个数据元素还需要存储指向第一个邻接点的指针，以便查找该顶点的边信息。</li><li>每个顶点的所有邻接点构成一个线性表，由于邻接点的个数不确定，因此可以使用单向链表来存储，<strong>无向图</strong>称为<strong>顶点的边表</strong>，<strong>有向图</strong>称为<strong>顶点作为弧尾的出边表</strong>。</li></ul><img src="/ee040603/image-20200430175019487.png" alt="image-20200430175019487" style="zoom:50%;"><p>但是由于有向图是有方向的，以顶点为弧尾来存储边表，这样就可以得到一个以顶点为弧尾的出边表；同时可以顶点为弧头来存储边表，可以得到一个以顶点为弧头的入边表，称作有向图的逆邻接表。</p><img src="/ee040603/image-20200430180927150.png" alt="image-20200430180927150" style="zoom:50%;"><p>对于带权值得网图：</p><img src="/ee040603/image-20200430181008980.png" alt="image-20200430181008980" style="zoom:50%;"><p>创建邻接表得时间复杂度为<code>O(n+e)</code>.</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>对于有向图来说，当使用邻接表时，当查找了出度问题，若想要了解入度则必须重新遍历整个图才能知道。反之，逆邻接表也有同样问题。为了解决这个问题，提出了<strong>十字链表（Orthogonal List）</strong>。</p><p>重新定义顶点表：</p><img src="/ee040603/image-20200430184522775.png" alt="image-20200430184522775" style="zoom: 80%;"><p><code>firstin</code> 表示入边表头指针，指向该顶点得入边表中第一个结点；<code>firstout</code>表示出边表头指针，指向该顶点得出边表中得第一个结点。</p><p>重定义得边表结点结构：</p><img src="/ee040603/image-20200430184933348.png" alt="image-20200430184933348" style="zoom:80%;"><p><code>tailvex</code>指弧起点在顶点表得下标，<code>headvex</code>表示弧终点在顶点表中得下标，<code>headlink</code>指入边表指针域，指向终点相同得下一条边，<code>taillink</code>是指边表指针域，指向起点相同得吓一条边。</p><p><img src="/ee040603/image-20200430185328973.png" alt="image-20200430185328973"></p><p>十字链表中得实线很好理解，就是正常得邻接表。重点是虚线得理解：其中虚线指向得就是以此顶点为弧头的弧，即通过<code>firstin</code>指针域出发，指向以此顶点为弧头的弧，同时若有多条弧进入，则可以通过边表结点中的<code>headline</code>指针域作为<strong>指向同一终点的下一条边</strong>的特性作为跳板，指向其他入弧。</p><p>十字链表的<strong>好处</strong>：</p><p>由于十字链表把邻接表和逆邻接表整合在一起，这样可以很容易求得顶点的出度和入度。十字链表的创建和邻接表的时间复杂度是相同的，因此在有向图中，十字链表是非常好的数据结构模型。</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>在无向图中，若更多关注的是顶点，则选择邻接表是一个不错的选择。但是若选择更多的关注的是<strong>边</strong>则选择邻接表就不是一个明智的选择了，因为当删除某条边后，则需要找到这条边表格结点进行操作，这就会变得麻烦不简洁。可以借鉴十字链表的特点，对边表结点的结构进行改变。</p><p>重新定义的边表结点的结构如下：</p><img src="/ee040603/image-20200430220538244.png" alt="image-20200430220538244" style="zoom:67%;"><p><code>ivex</code>和<code>jvex</code>表示与某条边依附的两个顶点在顶点表中的下标。<code>ilink</code>指向依附顶点<code>ivex</code>的下一条边，<code>jlink</code>指向依附顶点<code>jvex</code>的下一条边。这就是<strong>多重表结构</strong>。</p><p><img src="/ee040603/image-20200430220943312.png" alt="image-20200430220943312"></p><p>邻接多重表和邻接表的差别，仅仅在于<strong>同一条边在邻接表中用两个节点表示，而在邻接多重表中只有一个结点。</strong></p><p>若删除某条边，只需让相应的指针指向空即可，完成删除操作。</p><h2 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h2><p>边集数组是由两个一维数组构成。一个存储顶点的信息；另一个存储边的信息，这个边数组每个数据元素由一条边的起点下标、终点下标和权值构成。</p><img src="/ee040603/image-20200430222827311.png" alt="image-20200430222827311" style="zoom: 80%;"><p>边集数组<strong>关注的是变得集合</strong>，在边集数组中若要查找某个顶点的度需要扫描整个边数组，效率并不高。因此它<strong>更适合对边依次进行处理的操作，而不适合对顶点相关操作</strong>。</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>深度优先遍历（Depth_First_Search），也称为深度优先搜索，简称为DFS。</p><p>深度优先遍历就是从图中某个顶点<code>v</code>出发，访问此顶点，然后从<code>v</code>的未被访问的邻接点出发深度优先遍历图，直至图中所有和<code>v</code>有路径相同的顶点都被访问到。</p><p><strong>对于非连通图来说</strong>，只需对图中各个连通图依次进行深度优先遍历。</p><p><strong>邻接矩阵</strong>的深度优先遍历代码操作：</p><p><img src="/ee040603/image-20200501080222693.png" alt="image-20200501080222693"></p><p>对于<strong>邻接表</strong>的深度优先遍历：</p><p><img src="/ee040603/image-20200501080425932.png" alt="image-20200501080425932"></p><p>两种不同存储结构的深度优先遍历算法，由于邻接矩阵要查找每个顶点，需要访问矩阵中的所有元素，因此时间复杂度为<code>O(n^2)</code>；而邻接表查找某个顶点，需要的时间取决于顶点和边的数量，时间复杂度为<code>O(n+e)</code>,故当点多边少的图来说，邻接表存储结构的深度遍历时间效率更高。</p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>广度优先遍历（Breadth_First_Search），又称为广度优先搜索，简称BFS。</p><p>广度优先遍历，即将确定开始的顶点作为第一层，与之相邻的顶点作为第二层，以此类推，把全部顶点按照层次从新排列，然后对每一层进行遍历。</p><img src="/ee040603/image-20200501091550820.png" alt="image-20200501091550820" style="zoom:50%;"><p><strong>邻接矩阵</strong>的广度优先遍历：</p><p><img src="/ee040603/image-20200501092100389.png" alt="image-20200501092100389"></p><p>时间复杂度为<code>O(n^2)</code>。</p><p><strong>邻接表</strong>广度优先遍历：</p><p><img src="/ee040603/image-20200501093834170.png" alt="image-20200501093834170"></p><p>时间复杂度为<code>O(n+e)</code>，因为程序中的<code>while(p)</code>模块只有在<code>for() i=0</code>时执行一次，然后就不再执行了，只剩<code>for()</code>执行<code>n-1</code>次结束。</p><p>由此可以看出深度优先遍历和广度优先遍历算法在时间复杂度上是一样的。</p><p><strong>深度优先遍历更适合目标明确，为找到目标为目的的情况；而广度优先遍历更适合不断扩大范围时寻找最优解的情况</strong></p><h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="有环图应用"><a href="#有环图应用" class="headerlink" title="有环图应用"></a>有环图应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>把连通网图中由<code>n</code>个顶点和<code>n-1</code>条边组成的极小连通子图（也称为生成树），把其中最小代价（权值和）生成树称为最小生成树（Minimum Cost Spanning Tree）。</p><h4 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h4><p>Prim算法的操作代码如下：</p><p><img src="/ee040603/image-20200501110325626.png" alt="image-20200501110325626"></p><p>其中17~25行代码，循环当前的<code>lowcost</code>数组，找到最小权值<code>min</code>以及最小权值下标<code>k</code>。</p><p>28~35行代码，判断以<code>k</code>为顶点的邻接顶点的权值与<code>lowcost</code>数组中相应的权值大小，若小则替代<code>lowcost</code>数组中对应的权值，完成<code>lowcost</code>数组的更新；并将<code>adjvex</code>数组中相应下标的值改为<code>k</code>，完成<code>adjvex</code>数组的一次更新。</p><p>Prim算法的时间复杂度为<code>o(n^2)</code>.</p><p><img src="/ee040603/image-20200501112456945.png" alt="image-20200501112456945"></p><h4 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h4><p>Prim算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树。</p><p>也可以直接以变为目的去建立最小生成树，即直接寻找权值最小的边来构建最小生成树。但是要考虑是否形成环路。</p><p>因此用到了图存储结构中的<strong>边集数组</strong>，把边集数组按照权值的大小进行排序。</p><img src="/ee040603/image-20200501114032587.png" alt="image-20200501114032587" style="zoom:50%;"><p>Kruskal算法的操作代码：</p><p><img src="/ee040603/image-20200501115746082.png" alt="image-20200501115746082"></p><p>其中最重要的是<code>19~25</code>的查找代码，准确的算出，<code>n和m</code>的值。</p><p><img src="/ee040603/image-20200501120244904.png" alt="image-20200501120244904"></p><p>函数<code>Find</code>的时间复杂度为<code>O(loge)</code>，因此，kruskal算法的时间复杂度为<code>O(eloge)</code></p><p><strong>对比：</strong></p><p>kruskal算法主要是<strong>针对边</strong>来展开，边数少时效率会非常高，对<strong>稀疏图</strong>有很大优势；prim算法对于<strong>稠密图</strong>，即边非常多的情况会更好。</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>在网图和非网图中，最短路径的含义是不同的。由于<strong>非网图</strong>它没有边上的权值，最短路径是指<strong>两顶点之间经过的边数最少路径</strong>；对于<strong>网图</strong>来说，最短路径，是指两顶点之间经过的<strong>边上权值之和</strong>最少的路径，并且称第一个点为源点，最后一个顶点为终点。</p><h4 id="迪杰斯特拉（Dijkstra）算法"><a href="#迪杰斯特拉（Dijkstra）算法" class="headerlink" title="迪杰斯特拉（Dijkstra）算法"></a>迪杰斯特拉（Dijkstra）算法</h4><p>Dijkstra算法是一个基于之前最短路径长度递增的次序，从而产生最短路径的算法。</p><img src="/ee040603/image-20200501182818488.png" alt="image-20200501182818488" style="zoom:50%;"><p>Dijkstra算法的操作代码：</p><p><img src="/ee040603/image-20200501182954891.png" alt="image-20200501182954891"></p><p>其实这个Dijkstra算法的操作思路和最小生成树中的Prim算法是一样的。都是以<code>v0</code>相关的权值信息来初始化数组（具体数组的功能不同）。</p><p><code>final[]</code>数组是用来标记是否已经遍历过某顶点了。<code>P[]</code>数组存储当前最小距离的顶点下标。<code>D[]</code>数组存储当前的最小路径。</p><p>17~23行代码，表示寻找数组<code>D[]</code>中的最小值<code>min</code>，并令最小值的下标令为<code>k</code>。</p><p>25~32行代码，表示遍历以<code>vk</code>为顶点的邻接边的权值，通过比较之前得到的最短路径<code>min</code>与<code>vk</code>邻接边<code>w</code>权值之和与数组<code>D[w]</code>相比较，将较小的值替换掉数组<code>D[w]</code>中的值。同时更新数组<code>P[w]</code>中的值为<code>k</code>。</p><p>Dijkstra算法的时间复杂度为<code>O[n^2]</code>。</p><p>Dijkstra算法<strong>解决了从某个源点到其余各顶点的最短路径问题</strong>，它的局限性就是只能求取特定源点的最短路径。</p><h4 id="弗洛伊德（Floyd）算法"><a href="#弗洛伊德（Floyd）算法" class="headerlink" title="弗洛伊德（Floyd）算法"></a>弗洛伊德（Floyd）算法</h4><img src="/ee040603/image-20200501220553423.png" alt="image-20200501220553423" style="zoom: 80%;"><p>Floyd算法的操作代码：</p><p><img src="/ee040603/image-20200501220918696.png" alt="image-20200501220918696"></p><p>由于所求的是<strong>所有顶点到所有顶点的最短路径</strong>，因此数组<code>P[]、D[]</code>都是二维数组。</p><p>Floyd算法的核心就是，遍历数组<code>D[]</code>中的元素的权值，同时与以各个顶点为跳转点的路径权值做对比，将较小的一组值保留在数组<code>D[]</code>中，同时更改数组<code>P[]</code>中的值（<code>P[v][w]=k</code>k是跳转顶点下标）。</p><p>经过上述代码，可以得到如下数组矩阵：</p><p><img src="/ee040603/image-20200501221857239.png" alt="image-20200501221857239"></p><p>通过这两个数组，可以求出<strong>所有顶点到所有顶点的最短路径权值</strong>。</p><p>求任意最短路径的操作代码：</p><img src="/ee040603/image-20200501222629450.png" alt="image-20200501222629450" style="zoom:80%;"><p>通过代码可知，时间复杂度为<code>O(n^3)</code></p><p>当面临<strong>求所有顶点到所有顶点的最短路径</strong>时，Floyd算法是个不错的选择。</p><h2 id="无环图应用"><a href="#无环图应用" class="headerlink" title="无环图应用"></a>无环图应用</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的<strong>有向图为顶点表示活动的网</strong>，这称之为AOV网（Activity On Vertex Network）AOV网中的<strong>弧表示活动之间存在某种制约关系。</strong></p><p>图<code>G</code>是一个具有<code>n</code>个顶点的有向图，<code>V</code>中的顶点序列<code>v1,v2,……,vn</code>,满足若从顶点<code>vi</code>到<code>vj</code>有一条路径，则在顶点序列中顶点<code>vi</code>必须在顶点<code>vj</code>之前，则称这样的<strong>顶点序列</strong>为一个拓扑序列。<strong>拓扑序列不止一条</strong></p><p><strong>拓扑排序，就是对一个有向图构造拓扑序列的过程</strong></p><p>若此网的<strong>全部顶点都被输出</strong>，则说明它是<strong>不存在环的</strong>的AOV网；若<strong>输出顶点少了</strong>，哪怕是少了一个，说明这个<strong>网中存在环</strong> ,不是AOV网。</p><h4 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h4><p>对AOV网进行拓扑排序的<strong>基本思路</strong>是：</p><p><strong>从AOV网中选择一个入度为<code>0</code>的顶点输出，然后删除此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为<code>0</code>的顶点为止。</strong></p><p>由于在拓扑排序中，<strong>需要删除顶点</strong>，显然用<strong>邻接表</strong>会更加方便。</p><p>顶点表结构如下：</p><p><img src="/ee040603/image-20200502085618935.png" alt="image-20200502085618935"></p><p><code>in</code>是<strong>顶点的入度</strong>。</p><img src="/ee040603/image-20200502085901482.png" alt="image-20200502085901482" style="zoom:67%;"><p>在算法中，引入了栈的概念，目的是为了把入度为<code>0</code>的顶点存储到栈中，目的是为了避免每次查找时都要遍历顶点表中有没有入度为<code>0</code>的顶点。</p><p>下面是拓扑排序算法的操作代码：</p><p><img src="/ee040603/image-20200502094518386.png" alt="image-20200502094518386"></p><p>核心代码是12~23行代码，实现了入度为<code>0</code>的顶点压入栈中，以及输出打印栈中顶点，统计输出顶点数以判断是否会存在回环，同时解决了删除相应弧后邻接点的何去何从的问题。</p><p>此算法的时间复杂度为<code>O(n+e)</code>。9<del>11行对各顶点的遍历的时间复杂度为<code>O(n)</code>，12</del>23行代码，主要完成每个顶点按照一定的排序依次输出，换句话说就是，<strong>把每条弧依次删除后，从而得到了顶点的输出顺序</strong>（这只是自己的理解，不对之处还请指教）因次此段代码的时间复杂度为<code>O(e)</code>。因此，此算法的时间复杂度为<code>O(n+e)</code>。</p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种<strong>有向图的边</strong>表示活动的网，称为AOE网（Activity On <strong>Edge</strong> Network）</p><p>在AOE网中，没有入边的顶点称为源点或始点，没有出边的顶点叫做汇点或终点。</p><img src="/ee040603/image-20200502100600789.png" alt="image-20200502100600789" style="zoom:80%;"><p>AOE网和AOF网还是有区别的，从名字上就可以看出，AOE网更注重<strong><code>Edge</code></strong>;而AOF网更注重的是<strong><code>Vertex</code></strong>，它只描述活动之间的制约关系。 </p><p>把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有<strong>最大长度</strong>的路径叫做<strong>关键路径</strong>，在关键路径上的活动称为<strong>关键活动</strong>（弧）</p><h4 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h4><p>为了获得关键路径，首先要找到所有的关键活动。那么关键活动如何寻找呢？如下：</p><p>找到活动的最早开始时间以及最晚开始时间，若最早和最晚开始时间相等，则说明此活动没有空闲时间，可以作为关键活动；反之说明含有空闲时间，不能作为关键活动。</p><p>定义以下几个参数：</p><ul><li><strong>事件</strong>的最早发生时间<code>etv</code>(earliest time of vertex)：即顶点最早发生时间（）</li><li><strong>事件</strong>的最晚发生时间<code>ltv</code>(latest time of vertex)：即顶点最晚发生时间（）</li><li><strong>活动</strong>最早开工时间<code>ete</code>(earliest time of edge)：即弧的最早发生时间（<strong>在数值上，和事件最早发生时间<code>etv</code>相同</strong>）</li><li><strong>活动</strong>最晚开工时间<code>lte</code>(latest time of edge)：即弧的最晚发生时间（<strong>在数值上，为下一事件开始之前</strong>）</li></ul><p>可以通过<code>etv\ltv</code>求出<code>ete\lte</code>，通过判断<code>ete</code>是否等于<code>lte</code>来判断是否为关键活动。</p><img src="/ee040603/image-20200502103244203.png" alt="image-20200502103244203" style="zoom:67%;"><p>改进后的拓扑排序算法操作代码：</p><p><img src="/ee040603/image-20200502110605267.png" alt="image-20200502110605267"></p><p>主要的改进就是加粗的部分代码，它主要新增了一个栈<code>stack2</code>用来存储输出的拓扑序列。同时求出了<code>etv</code>的数组值。</p><p>可知，计算顶点事件最早发生时间公式如下:</p><p><img src="/ee040603/image-20200502111147877.png" alt="image-20200502111147877"></p><p>因为<code>etv</code>一开始初始化为<code>0</code>，所以当<code>k!=0</code>时就如所给公式中一样了。</p><p>求取关键路径的操作代码：</p><p><img src="/ee040603/image-20200502114137174.png" alt="image-20200502114137174"></p><p>主要时通过求拓扑序列，得到的拓扑路径<code>stack2</code>和事件最早开始时间<code>etv</code>来求取：事件最晚开始时间<code>ltv</code>；活动最早发生时间<code>ete</code>,活动最晚发生时间<code>lte</code>.然后通过判断<code>ete</code>与`lte是否相等来判断关键路活动，从而得到关键路径。</p><p><img src="/ee040603/image-20200502115357898.png" alt="image-20200502115357898"></p><p>在实际工程中，<strong>可能存在多条关键路径</strong>，此时<strong>必须同时提高在几条关键路径上的关键活动速度</strong>。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/6534ce06.html"/>
      <url>/6534ce06.html</url>
      
        <content type="html"><![CDATA[<hr><p><img src="/6534ce06/image-20200428190107477.png" alt="image-20200428190107477"></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><blockquote><p>栈：限定<strong>仅</strong>在表尾进行插入和删除操作的<strong>线性表</strong>。</p></blockquote><p>栈又称为<strong>后进先出</strong>（Last In First Out）线性表，简称LIFO结构。</p><img src="/6534ce06/image-20200425084743968.png" alt="image-20200425084743968" style="zoom:50%;"><p>栈对线性表的插入和删除的位置进行了限制，但是并没有对何时插入与删除进行限制，在<strong>不是所有元素都进栈，并保证栈顶元素出栈的情况下</strong>，先进入的可以不必最后出。</p><h2 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>对于顺序存储结构，可以通过数组来实现。一般将下标为0的一端作为栈底，这样当存入和删除元素时，数组变化最小。定义top变量指代栈顶元素在数组中的位置，但是top变量必须小于数组的长度。<strong>当栈存在一个元素时，top记为0，因此把空栈的top记为-1</strong>.</p><p>假设有5个元素下栈的几种可能情况。</p><img src="/6534ce06/image-20200425095242395.png" alt="image-20200425095242395" style="zoom:50%;"><p>push操作代码：</p><img src="/6534ce06/image-20200425095700751.png" alt="image-20200425095700751" style="zoom:50%;"><p>pop操作代码：</p><img src="/6534ce06/image-20200425095740831.png" alt="image-20200425095740831" style="zoom:50%;"><h4 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h4><p>为了最大程度上利用数组的空间，可以通过将两个<strong>同类型</strong>的栈组合起来，一起共享数组空间。将两个栈底分别作为数组的起始端和末端。如图：</p><img src="/6534ce06/image-20200425101135540.png" alt="image-20200425101135540" style="zoom:50%;"><p>只要top1和top2两个栈顶指针不相遇，两个栈就可以一直使用。</p><blockquote><p>当top1等于-1时，栈1为空；当top2等于n时，栈2为空。</p><p>当栈2为空，top1等于n-1时，栈1满栈；当top2等于0时，栈2满栈。</p></blockquote><p>当两个指针之间相差1时，即 top1 + 1 == top2 时栈是满栈。</p><p>两栈共享空间的push操作代码：</p><img src="/6534ce06/image-20200425104129706.png" alt="image-20200425104129706" style="zoom:50%;"><p>注意，红色部分，++i 与 i++ 的区别。</p><p>pop操作代码：</p><img src="/6534ce06/image-20200425104320630.png" alt="image-20200425104320630" style="zoom:50%;"><p>使用这种数据结构，通常是两个栈的空间需求有相反关系时，即一个栈空间增加而另一个栈空间缩小。</p><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>栈的链式存储结构，可以简称为链栈。</p><p>由于链表含有头指针的单链表头，因此可以通过单链表头作为栈顶。效果图如下：</p><img src="/6534ce06/image-20200425105324677.png" alt="image-20200425105324677" style="zoom:50%;"><p>对于空栈来说，由于空链表定义的头指针指向空，则链栈的空其实就是 top=NULL。</p><p>push操作代码：</p><img src="/6534ce06/image-20200425110352448.png" alt="image-20200425110352448" style="zoom:50%;"><img src="/6534ce06/image-20200425110545084.png" alt="image-20200425110545084" style="zoom:50%;"><p>pop操作：</p><img src="/6534ce06/image-20200425110723458.png" alt="image-20200425110723458" style="zoom:50%;"><img src="/6534ce06/image-20200425110750706.png" alt="image-20200425110750706" style="zoom:50%;"><p>通过链栈和顺序栈的比较可知：<strong>在栈的使用过程中，若使用的元素变化不可预测，时大时小，则最好使用链栈，若知道在可控的范围内，则使用顺序栈更好</strong>。</p><h2 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h2><p>栈的引用，简化了程序设计的问题，划分了不同关注层次，使思考范围缩小，更聚焦当前要解决的问题。数组之类的，还需要分散精力去考虑数组下标增减等细节问题。</p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>定义：<strong>直接调用自己或通过一些列的调用语句间接地调用自己的函数，称作递归函数。</strong></p><p><strong>注意：</strong>递归的最大陷阱就是要防止进入<strong>无限递归</strong>因此在<strong>每个递归定义必须至少有一个条件，满足时递归不再进行。</strong></p><p>运用递归能使程序的<strong>结构更清晰、更简洁、更容易理解，从而减少读懂代码的时间</strong>。但是大量的递归调用会建立函数的副本，会<strong>耗费大量时间和内存</strong>。迭代则不需要反复调用函数和占用额外的内存。</p><p>栈和递归的关系：</p><p>在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址<strong>都被压入栈</strong>中。在退回阶段，位于栈顶的局部变量、参数值和返回地址<strong>被弹出</strong>，用于返回调用层次中执行代码的其余部分，即恢复调用的状态。</p><h3 id="四则运算表达式求值"><a href="#四则运算表达式求值" class="headerlink" title="四则运算表达式求值"></a>四则运算表达式求值</h3><p>后缀表达式规则：</p><p>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。<br>$$<br>9+(3-1)×3+10÷2<br>$$<br>示例:</p><p><img src="/6534ce06/image-20200425180452247.png" alt="image-20200425180452247"></p><p>在平常的四则运算中的表达式叫做中缀表达式。中缀表达式转换为后缀表达式的规则：</p><p><strong>从左到右遍历表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</strong></p><p>想让计算机处理常用的中缀表达式，最重要的是以下两步：</p><ul><li>将中缀表达式转化为后缀表达式（栈用来<strong>进出运算的符号</strong>）</li><li>将后缀表达式进行运算得出结果（栈用来<strong>进出运算的数字</strong>）</li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列（queue）是<strong>只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong></p><p>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为对头。</p><img src="/6534ce06/image-20200426080824944.png" alt="image-20200426080824944" style="zoom:50%;"><h2 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h2><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>队列的顺序存储结构需要建立一个大于n的数组，但是由于队列的特殊性（先进先出）入队操作，只需在数组后加一个元素，不需要移动任何元素，此时复杂度为O(1)。但是，在出队操作时，需要删除数组第一个元素，则需要把<strong>所有</strong>元素都向前移动，此时的时间复杂度为O(n)。</p><img src="/6534ce06/image-20200426083633132.png" alt="image-20200426083633132" style="zoom:50%;"><p>为了避免出队列时，增加时间复杂度，引入两个指针，front指针指向队头元素，rear指针指向队尾元素的<strong>下一个位置</strong>，当front等于rear时，此队列是空队列。</p><img src="/6534ce06/image-20200426084014937.png" alt="image-20200426084014937" style="zoom:50%;"><p>假溢出：在入队时，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，而且<strong>队列的前端还有空闲</strong>，把这种现象称为假溢出。</p><img src="/6534ce06/image-20200426084643305.png" alt="image-20200426084643305" style="zoom:50%;"><p>为了解决假溢出的问题，引入了循环队列：把队列的头尾相接的顺序存储结构称为循环队列。</p><img src="/6534ce06/image-20200426090055084.png" alt="image-20200426090055084" style="zoom:50%;"><p>但此时的问题是：当front指针等于rear指针时，此时队列为空。但是此时，front指针等于rear指针，队列为满。</p><p>那么如何判断当front指针等于rear时，队列是空还是满呢？</p><ul><li>设置一个标志变量flag，当front==rear，且flag = 0时队列为空，当flag=1时队列为满。</li><li>办法二，当队列为空时，条件就是front ==rear，当队列满时，修改其条件，<strong>保留一个元素空间</strong>。</li></ul><img src="/6534ce06/image-20200426092144219.png" alt="image-20200426092144219" style="zoom:50%;"><p>上图即为方法二的满队情况。</p><p>在满队的情况下，rear有可能比front大也可能小。需要通过以下方法来判断队列满。</p><p>设队列的最大尺寸为QueueSize,那么队列满的条件是<strong>(rear+1)%QueueSize == front</strong>.</p><p><strong>通用的队列长度计算公式：</strong>（rear-front + QueueSize）%QueueSize</p><p>循环队列的顺序存储结构代码如下：</p><img src="/6534ce06/image-20200426093308450.png" alt="image-20200426093308450" style="zoom:50%;"><p>循环队列的初始化代码如下：</p><img src="/6534ce06/image-20200426093357676.png" alt="image-20200426093357676" style="zoom:50%;"><p>循环队列求长度代码：</p><img src="/6534ce06/image-20200426093550305.png" alt="image-20200426093550305" style="zoom:50%;"><p>循环队列的入队操作：</p><img src="/6534ce06/image-20200426093644631.png" alt="image-20200426093644631" style="zoom:50%;"><p>循环队列的出队操作：</p><img src="/6534ce06/image-20200426093915183.png" alt="image-20200426093915183" style="zoom:50%;"><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><p> 队列的链式存储结构，其实就是线性表的单链表，只是只能尾进头出，简称为链队列。将头指针指向链队列的头结点，队尾指针指向终端结点。</p><img src="/6534ce06/image-20200426100400135.png" alt="image-20200426100400135" style="zoom:50%;"><p>当队列为空时，头指针和尾指针都指向头结点。</p><img src="/6534ce06/image-20200426100532695.png" alt="image-20200426100532695" style="zoom:50%;"><p>入队操作：</p><p><img src="/6534ce06/image-20200426100623318.png" alt="image-20200426100623318"></p><p><img src="/6534ce06/image-20200426100751336.png" alt="image-20200426100751336"></p><p>出队操作：</p><p><img src="/6534ce06/image-20200426100826898.png" alt="image-20200426100826898"></p><img src="/6534ce06/image-20200426101449339.png" alt="image-20200426101449339" style="zoom:50%;"><p>在可以确定队列长度最大值的情况下，建议用循环队列，若无法预估计队列的长度时，则用链队列。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表笔记之于大话数据结构</title>
      <link href="/b6f9ab9c.html"/>
      <url>/b6f9ab9c.html</url>
      
        <content type="html"><![CDATA[<hr><p>本文主要是通过阅读大话数据结构第三章，总结一些自己对线性表得所得与所想，希望能对您有所帮助，也为方便自己日后查阅。若有错误之处，请大佬指出:happy:</p><a id="more"></a><p><img src="/b6f9ab9c/image-20200410172957516.png" alt></p><h1 id="线性表得定义"><a href="#线性表得定义" class="headerlink" title="线性表得定义"></a>线性表得定义</h1><p><code>定义：零个或多个数据元素的有限序列。</code></p><p>线性表有以下特性：</p><blockquote><p>线性表是个序列。元素之间是<strong><em>有顺序</em></strong>的，除第一个和最后一个，每个元素都<strong>有且只有</strong>一个前驱和后继。</p><blockquote><p>线性表是<strong><em>有限的</em></strong>。</p><p>数据元素的类型是一样的。</p></blockquote></blockquote><h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p>线性链表的抽象数据类型，也就是时说线性表应该有什么样的操作呢。</p><p>线性表的抽象数据类型定义如下：</p><img src="/b6f9ab9c/3.1.jpg" style="zoom:33%;"><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p>顺序存储结构定义：<code>用一段地址连续的存储单元依次存储线性表的数据元素。</code></p><p>线性表的存储示意图如下：</p><img src="/b6f9ab9c/3.2.jpg" style="zoom:33%;"><h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><p>可以通过<strong>一维数组来实现顺序存储结构</strong>。</p><p>线性表的顺序存储的结构代码：</p><p><img src="/b6f9ab9c/3.3.jpg" alt></p><h3 id="数据长度与线性表长度区别"><a href="#数据长度与线性表长度区别" class="headerlink" title="数据长度与线性表长度区别"></a>数据长度与线性表长度区别</h3><p>区别如下：</p><p><img src="/b6f9ab9c/image-20200410094544007.png" alt="image-20200410094544007"></p><h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3><p>由于存储器中的每个存储单元都有自己的编号，即地址。假设每个数据元素都占用一个固定的存储单元c，那么可以得到任意存储位置的地址：<br>$$<br>LOC(a_i)=LOC(a_1)+(i-1)*c<br>$$<br>对顺序存储结构的线性表来说，存入或者取出数据，的时间复杂度都为O(1)。通常把具有这一特点的存储结构称为随机存取结构。</p><h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>要是实现获得数据GetElem操作，只要 i 的数值在数组下标范围内，就是把数组第 <code>i-1</code>下标返回即可。代码如下：</p><p><img src="/b6f9ab9c/3.5.jpg" alt></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>要实现<code>ListInsert(*L,i,e)</code>，即在线性表L中的第i个位置插入新元素e，该如何操作？</p><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表长度大于数组长度，则抛出异常或动态增加容量；</li><li>从<strong>最后一个元素开始向前遍历</strong>到第 <code>i</code> 个位置，分别将它们都向后移动一个位置；</li><li>将要插入的元素填入位置<code>i</code>处；</li><li>表长加1；</li></ul><p>代码实现如下：</p><img src="/b6f9ab9c/3.6.jpg" style="zoom:50%;"><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常；</li><li>取出删除元素；</li><li>从<strong>删除元素位置</strong>，开始遍历到最后一个元素位置，分别将它们都向前移动一个个位置；</li><li>表长减1；</li></ul><p>实现代码如下：</p><p><img src="/b6f9ab9c/3.7.jpg" alt></p><p>插入和删除的时间复杂度都为<code>O(n)</code></p><h4 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h4><p>优缺点总结如下：</p><p><img src="/b6f9ab9c/image-20200410104532727.png" alt="image-20200410104532727"></p><h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><p>线性链表的特点：</p><ul><li>用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这些元素可以在未被占用内存的任意位置。</li></ul><p>链式存储结构的组成部分：</p><ul><li>数据域：用来存储数值信息；</li><li>指针域：用来指向后继元素存储地址的指针。</li></ul><p>把一个元素的指针域和数据域组成的存储映像，称为<strong>节点</strong>。</p><img src="/b6f9ab9c/image-20200410105654619.png" alt="image-20200410105654619" style="zoom:50%;"><p><strong>把链表中第一个节点的存储位置叫做头指针</strong>，整个链表都是从头指针开始进行的。</p><p>最后一个节点的指针为空（通常用<code>NULL</code>或<code>&quot;^&quot;</code>表示）。</p><img src="/b6f9ab9c/image-20200410110627268.png" alt="image-20200410110627268" style="zoom:50%;"><p>通常在第一个节点前添加一个头节点。头节点的数据域可以为空，也可以存储线性表的长度等附加信息。</p><p>头节点和头指针的区别：</p><img src="/b6f9ab9c/image-20200410112358275.png" alt="image-20200410112358275" style="zoom:50%;"><p>通过下图可更加直观的明白头指针和头结点大的区别：</p><img src="/b6f9ab9c/3.8.jpg" style="zoom:50%;"><p>假设<code>p</code>是指向线性表的第<code>i</code>个元素的指针，该结点的数据域为<code>p-&gt;data</code>值是一个数据元素，指针域为<code>p-&gt;next</code>是一个指针。</p><img src="/b6f9ab9c/image-20200410113228723.png" alt="image-20200410113228723" style="zoom:50%;"><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><p>获得链表第<code>i</code>个数据的算法思路：</p><ul><li>声明一个结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从<code>1</code>开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让<code>p</code>的指针向后移动，不断指向下一个结点，<code>j</code>累加1；</li><li>若到链表末尾<code>p</code>为空，则说明第<code>i</code>个元素不存在；</li><li>否则查找成功，返回结点<code>p</code>的数据；</li></ul><p>实现代码为：</p><img src="/b6f9ab9c/3.9.jpg" style="zoom:50%;"><p>简单说就是从头开始遍历，直到第<code>i</code>个元素为止。此时的时间复杂度，最差为<code>O(n)</code></p><h4 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h4><img src="/b6f9ab9c/image-20200410115837689.png" alt="image-20200410115837689" style="zoom:50%;"><p>要把<code>s</code>结点插入，则只需，<code>s-&gt;next=p-&gt;next</code>和<code>p-&gt;next=s</code>即可。切记这<strong>两句命令不能顺序颠倒</strong>。把p的后继结点改为s的后继结点，再把结点s改成p的后继结点。</p><p>在表头和表尾的插入操作：</p><img src="/b6f9ab9c/image-20200410120406379.png" alt="image-20200410120406379" style="zoom:50%;"><p>单链表第i个数据插入结点的算法思路：</p><ul><li>声明一个结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从1开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让<code>p</code>的指针向后移动，不断指向下一结点，<code>j</code>累加1；</li><li>若到链表末尾<code>p</code>为空，则说明第<code>i</code>个元素不存在；</li><li>否则查找成功，在系统中生成一个空结点s；</li><li>将数据元素<code>e</code>赋值给<code>s-&gt;data</code>；</li><li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next; p-&gt;next=s;</code>;</li><li>返回成功；</li></ul><p>代码如下：</p><img src="/b6f9ab9c/image-20200410130928070.png" alt="image-20200410130928070" style="zoom:50%;"><h4 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h4><img src="/b6f9ab9c/image-20200410131049102.png" alt="image-20200410131049102" style="zoom:50%;"><p>只需要做<code>p-&gt;next=p-&gt;next-&gt;next</code>,即可。令<code>q=p-&gt;next</code>。</p><p>单链表删除的算法步骤：</p><ul><li>声明一结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从<code>1</code>开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，<code>j</code>累加1；</li><li>若链表末尾p为空，则说明第 i 个元素不存在；</li><li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li><li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>;</li><li>将<code>q</code>结点中的数据赋值给<code>e</code>，作为返回；</li><li>释放<code>q</code>结点；</li><li>返回成功；</li></ul><p>实现代码如下：</p><img src="/b6f9ab9c/image-20200410131903592.png" alt="image-20200410131903592" style="zoom:50%;"><h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><p>创建单链表的过程是一个动态生成链表的过程，即从空表的初始状态，依次建立各元素结点，并逐个插入链表。</p><p>头插法：</p><p>单链表整表创建的算法思路：</p><ul><li>声明一个结点<code>p</code>和计数器变量<code>i</code>;</li><li>初始化一个空链表L；</li><li>让<code>L</code>的头结点的指针指向NULL,即建立一个带头结点的单链表；</li><li>循环：<ul><li>生成一个新节点赋值给<code>p</code>；</li><li>随机生成一个数字赋值给<code>p</code>的数据域<code>p-&gt;data</code>；</li><li>将<code>p</code>插入到头结点与之前新一结点之间；</li></ul></li></ul><p>代码实现如下：</p><img src="/b6f9ab9c/3.10.jpg" style="zoom:50%;"><p>如图所示：</p><img src="/b6f9ab9c/image-20200410133936036.png" alt="image-20200410133936036" style="zoom:50%;"><p>事实上很少有使用头插法的，因为自古以来都是“先来后到之说”。</p><p>尾插法代码如下：</p><img src="/b6f9ab9c/3.11.jpg" style="zoom:50%;"><p>流程图如下：</p><img src="/b6f9ab9c/image-20200410134614497.png" alt="image-20200410134614497" style="zoom:50%;"><h4 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h4><p>单链表整表删除的算法思路如下：</p><ul><li>声明一个结点<code>p</code>和<code>q</code>；</li><li>将第一个结点赋值给<code>p</code>；</li><li>循环：<ul><li>将下一个结点赋值给<code>q</code>；</li><li>释放<code>p</code>；</li><li>将<code>q</code>赋值给<code>p</code>；</li></ul></li></ul><p>实现代码如下：</p><img src="/b6f9ab9c/image-20200410135040331.png" alt="image-20200410135040331" style="zoom:50%;"><p><strong>代码中的<code>q</code>不能去除</strong>，因为<code>q</code>相当于寄存<code>p</code>结点后继结点的容器，若直接删除<code>p</code>而没有<code>q</code>会导致无法知道后继是谁，造成无法删除。</p><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><img src="/b6f9ab9c/image-20200410135648819.png" alt="image-20200410135648819" style="zoom:50%;"><ul><li>总之，若线性表中的元素个数变化较大，需要频繁的插入和删除操作时，宜采用单链表结构，反之对于知道数组大小，而且很少插入和删除的操作时宜采用顺序存储结构的线性表。</li></ul><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p><strong>静态链表主要是针对没有指针的语言，了解它更多的取其思想之精华，以为日后之借鉴。</strong></p><p>对于没有指针的语言来说，就不能像单链表一样通过指针域来进行链接。但是大佬就是大佬，他们提出使用数组来代替指针。</p><p>让数组的每个元素都是由两个数据域组成，<code>data</code>和<code>cur</code>。数组的每个下标都对应一个<code>data</code>和一个<code>cur</code>。<code>cur</code>叫做游标，相当于单链表中的next指针，存放后继元素中的数组下标。</p><p>通常对数组中第一个和最后一个元素，不存数据。</p><img src="/b6f9ab9c/3.12.jpg" style="zoom:50%;"><p>数组的第一个元素的<code>cur</code>存放备用链表的第一个结点的下标；最后一个元素的<code>cur</code>存放第一个有数值的元素的下标，相当于单链表中的头结点。</p><p>初始化的空的静态链表代码如下：</p><img src="/b6f9ab9c/image-20200410141849219.png" alt="image-20200410141849219" style="zoom:50%;"><h4 id="静态链表的插入"><a href="#静态链表的插入" class="headerlink" title="静态链表的插入"></a>静态链表的插入</h4><p>为了找到数组中哪些分量未被使用，通过将所有未被使用过的以及删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入得新节点。</p><p>返回待插入结点得下标代码：</p><img src="/b6f9ab9c/image-20200410142806293.png" alt="image-20200410142806293" style="zoom:50%;"><p>插入第i个元素的代码如下：</p><img src="/b6f9ab9c/image-20200410143030586.png" alt="image-20200410143030586" style="zoom:50%;"><img src="/b6f9ab9c/image-20200410143502306.png" alt="image-20200410143502306" style="zoom:50%;"><h4 id="静态链表的删除"><a href="#静态链表的删除" class="headerlink" title="静态链表的删除"></a>静态链表的删除</h4><img src="/b6f9ab9c/image-20200410155117543.png" alt="image-20200410155117543" style="zoom:50%;"><p>释放结点的实现代码：</p><img src="/b6f9ab9c/image-20200410162351065.png" alt="image-20200410162351065" style="zoom:50%;"><p>其中<code>Free_SSL(L, j)</code>为：</p><img src="/b6f9ab9c/image-20200410161553053.png" alt="image-20200410161553053" style="zoom:50%;"><img src="/b6f9ab9c/image-20200410155117543.png" alt="image-20200410155117543" style="zoom:50%;"><h4 id="静态链表的长度"><a href="#静态链表的长度" class="headerlink" title="静态链表的长度"></a>静态链表的长度</h4><p>实现代码：</p><img src="/b6f9ab9c/image-20200410162848974.png" alt="image-20200410162848974" style="zoom:50%;"><p>根据下面这个图就明白了：</p><img src="/b6f9ab9c/image-20200410163203790.png" alt="image-20200410163203790" style="zoom:50%;"><p><code>i</code>的初始值为<code>1</code>，然后一直循环，知道最后一个元素的cur值为0，即<code>i=0</code>后跳出循环，通过计数<code>j</code>得出元素的个数。</p><h4 id="静态链表的优缺点"><a href="#静态链表的优缺点" class="headerlink" title="静态链表的优缺点"></a>静态链表的优缺点</h4><img src="/b6f9ab9c/image-20200410163553225.png" alt="image-20200410163553225" style="zoom:50%;"><p>总上可知，静态链表主要是针对没有指针的语言。对于有指针的语言，不会用到它的。主要是学习其思想。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。</p><img src="/b6f9ab9c/image-20200410164234277.png" alt="image-20200410164234277" style="zoom:50%;"><p>循环链表和单链表的主要<strong>差异在循环的判断条件</strong>上：</p><ul><li>单链表是判断<code>p-&gt;next</code>是否为空，来判断是否停止；</li><li>循环链表是判断<code>p-&gt;next</code>是否等于头结点，来判断是否循环结束；</li></ul><p>将两个循环链表合并：</p><img src="/b6f9ab9c/image-20200410164737635.png" alt="image-20200410164737635" style="zoom:50%;"><p><img src="/b6f9ab9c/image-20200410164807110.png" alt="image-20200410164807110"></p><p>只需要执行以下代码即可实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = rearA-&gt;next;            <span class="comment">//保留A的头，即①</span></span><br><span class="line">rearA-&gt;next = rearB-&gt;next-&gt;next; <span class="comment">// 即A的尾指针指向B的第一个结点,即②</span></span><br><span class="line">rearB-&gt;next = p; <span class="comment">// B的尾指针指向A头结点，形成循环链表，即③</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// p是新建的一个指针，用完后要及时释放，否则可能会内存泄漏和占用            //内存</span></span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>为了克服链表单向性这一缺点，<strong>在单链表的每个结点中，再设置一个指向其前驱结点的指针域，形成双向链表</strong>。</p><p>双向循环链表：</p><img src="/b6f9ab9c/image-20200410170503719.png" alt="image-20200410170503719" style="zoom:50%;"><p><code>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next</code>这应该很好理解吧！</p><p>双向链表很多都是由单向链表扩展的，基本操作大同小异。但是在插入操作时要<strong>注意顺序</strong>，千万不能反了。</p><img src="/b6f9ab9c/image-20200410170906257.png" alt="image-20200410170906257" style="zoom:50%;"><img src="/b6f9ab9c/image-20200410170935055.png" alt="image-20200410170935055" style="zoom:50%;"><p>由于第2步和第3步，都用到了<code>p-&gt;next</code>如果先执行第四步，则使<code>p-&gt;next</code>提前变为<code>s</code>。<strong>顺序使先搞定<code>s</code>的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继</strong>。</p><p>删除操作：</p><img src="/b6f9ab9c/image-20200410171325723.png" alt="image-20200410171325723" style="zoom:50%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><hr><p>感谢阅读:smile:.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬取淘宝商品名称和价格</title>
      <link href="/a4e5e07c.html"/>
      <url>/a4e5e07c.html</url>
      
        <content type="html"><![CDATA[<hr><p>在B站上观看北京理工大学的爬虫慕课，在爬取淘宝商品价格和名称时出现了只出表头信息的结果。</p><a id="more"></a><p><img src="/a4e5e07c/p1.png" alt></p><p>经过在视频下方评论区的方法发现依然有错，最后发现是自己的拼写错误:joy:</p><p>发话不多说直接上教程：（<strong>我使用的是chrome浏览器</strong>）</p><p>在淘宝页面右键，点击检查：</p><img src="/a4e5e07c/p2.jpg" style="zoom:50%;"><p>然后在源代码区进行以下步骤：</p><ul><li><p>1、点击<code>Network</code></p></li><li><p>2、刷新页面，点击<code>Name</code>中的第一个<code>search?</code></p></li><li><p>3、在<code>Headers</code>中复制<code>cookie和user-agent</code>内容</p><p> <img src="/a4e5e07c/p3.jpg" alt></p></li></ul><p><strong>把复制的内容放到如下位置：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTML</span><span class="params">(url)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'解析开始'</span>)</span><br><span class="line">        headers = &#123;</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span>,</span><br><span class="line">        <span class="string">'cookie'</span>: <span class="string">'miid=1204848422178730713; thw=cn; cna=/FjUFFH98VYCAbfHca7IzgoX; tracknick=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; tg=0; hng=CN%7Czh-CN%7CCNY%7C156; enc=S9dNZWnBqTugKoqk7f9MpczA8QNKFdbWP8Dab4FEeTI43rFE%2B%2FrwSE7PnLJF%2BRA5yy70RD7m9rnCJyj72bByLg%3D%3D; t=23bd277878acd720dad699e1cc1f655d; cookie2=1266fc62e2cc3c4136c7085328db7985; v=0; _tb_token_=3fe6ee4e766b8; alitrackid=www.taobao.com; lastalitrackid=www.taobao.com; _samesite_flag_=true; sgcookie=EvIOOHQLzH3Oo804wQlio; unb=2278212962; uc3=lg2=VFC%2FuZ9ayeYq2g%3D%3D&amp;nk2=0ryj1fYS8gv0fQ%3D%3D&amp;vt3=F8dBxdAUzLP9Oq23c0M%3D&amp;id2=UUpmlOw4s1nHfg%3D%3D; csg=f123a494; lgc=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; cookie17=UUpmlOw4s1nHfg%3D%3D; dnk=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; skt=a5e20976396f587e; existShop=MTU4NjA4MzcyMA%3D%3D; uc4=id4=0%40U2gsGA%2BPaSbBR0Lnefhgm24jPZLA&amp;nk4=0%400A28Ox7kSTkcIvypO6o%2FqsLX5wQe; _cc_=VT5L2FSpdA%3D%3D; _l_g_=Ug%3D%3D; sg=%E9%A3%9E2f; _nk_=%5Cu51B0%5Cu6CB3%5Cu4E16%5Cu7EAA%5Cu98DE; cookie1=VAn7B4bWBvYsc6mrUjgaw%2F%2F8dWi4qfHRI6oPI3CZaYI%3D; tfstk=c47CBgD9vvDCt6DJ59NwYM0dAv8RZXe6sk9dOGUC18n-cLCCix02nXEhqA09DC1..; mt=ci=3_1; JSESSIONID=E9C7BE989C9A4781DC9BDF55EE086724; l=dBLuPSIcqWzW1J7tBOCgqDBHHA7TYIRAgulLJpFvi_5Iw6Y1A2QOo1N4MFv6cjWft28B4z6vzNe9-etlsn4pJA--g3fydxDc.; isg=BNDQjY51utpNoGWOeaq5eOihoR4imbTj3pjtcMqhxyv-BXCvcqgLcyd_3c3l1Wy7; uc1=cookie16=U%2BGCWk%2F74Mx5tgzv3dWpnhjPaQ%3D%3D&amp;cookie21=W5iHLLyFeYZ1WM9hVnmS&amp;cookie15=URm48syIIVrSKA%3D%3D&amp;existShop=false&amp;pas=0&amp;cookie14=UoTUPOT6s4ShJw%3D%3D&amp;tag=8&amp;lng=zh_CN'</span>,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">        h = requests.get(url, headers = headers)</span><br><span class="line">        h.raise_for_status()</span><br><span class="line">        h.encoding = h.apparent_encoding</span><br><span class="line">        <span class="comment">#print(h.text)</span></span><br><span class="line">        <span class="keyword">return</span> h.text</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'html解析失败'</span></span><br></pre></td></tr></table></figure><p>修改划线位置，把自己的user-agent和cookie粘贴即可。</p><p><img src="/a4e5e07c/p4.jpg" alt></p><p>至此，若代码没有拼写等低级错误就会成功输出正确信息。</p><p><img src="/a4e5e07c/p5.jpg" alt></p><p>我自己就是因为<u><strong>拼写错误</strong></u>只输出了表头。</p><p><img src="/a4e5e07c/p6.jpg" alt></p><hr><p>另外一个检查错误的技巧就是巧用print（）函数，来检查代码执行到哪里出错，以及是否输出正确信息。我就是通过这个方法一步步查找到<code>plt</code>得到的返回值为零，然后发现<code>price</code>拼写错误了。</p><hr><p>谢谢阅读:happy:</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各板块透明度设置（无坑版）</title>
      <link href="/undefined.html"/>
      <url>/undefined.html</url>
      
        <content type="html"><![CDATA[<p>在网上找了各种修改透明度的教程，一路踩坑终于调整成功！特此总结防止入坑。</p><a id="more"></a><p>效果预览：<a href="https://zeroflycui.github.io" target="_blank" rel="noopener">https://zeroflycui.github.io</a></p><h1 id="文章主题以及评论区透明度设置"><a href="#文章主题以及评论区透明度设置" class="headerlink" title="文章主题以及评论区透明度设置"></a>文章主题以及评论区透明度设置</h1><p>首先找到此路径  \blog\themes\next\source\css_schemes\Gemini 下的index.styl 文件。</p><img src="/undefined/路径1.jpg" style="zoom:50%;"><p>打开index.styl文件，把 .post-block 下的background后的改为rgba(255,255,255,0.6), 最后的数值是透明度设置，自己调整。</p><img src="/undefined/设置1.jpg" style="zoom:50%;"><p>效果：</p><img src="/undefined/背景透明度2.jpg" style="zoom:50%;"><h1 id="侧边栏透明度设置"><a href="#侧边栏透明度设置" class="headerlink" title="侧边栏透明度设置"></a>侧边栏透明度设置</h1><p>打开以下路径 \blog\themes\next\source\css_schemes\Pisces 下的_sidebar.styl,修改 .sidebar以及.sidebar-inner 下的background：rgba(255,255,255,0.6).如下图所示：</p><img src="/undefined/设置2.jpg" style="zoom:50%;"><p>效果图：</p><img src="/undefined/设置3.jpg" style="zoom:50%;"><hr><p>修改完成，如果有错请通知。谢谢阅读！！</p><p>参考博文链接：</p><p><a href="http://www.aomanhao.top/2019/01/20/theme_NextConfig1/" target="_blank" rel="noopener">http://www.aomanhao.top/2019/01/20/theme_NextConfig1/</a></p><p><a href="https://blog.csdn.net/qq_43414603/article/details/104113198" target="_blank" rel="noopener">https://blog.csdn.net/qq_43414603/article/details/104113198</a></p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
            <tag> 透明度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
